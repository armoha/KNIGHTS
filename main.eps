
const L_ANYWHERE = $L("Anywhere");
const L_MAIN = $L("main");
const L_3X3 = $L("3x3");
const L_16x16 = $L("16x16");

const U_HERO = 61;
const U_CHIMERA = 37;
const U_ANY = 229;

const ORDER_HOLD = 107;
const ORDER_PATROL = 152;

const p_cunit = PVariable();
const p_pos_x_old = PVariable();
const p_pos_y_old = PVariable();
const p_chunk_x_old = PVariable();
const p_chunk_y_old = PVariable();
const p_armor_max = PVariable();
const p_armor_recover = PVariable();
const p_attackspeed = PVariable();
const p_damage = PVariable();

const monster_spawn_type = EUDArray(1000);
const monster_spawn_x = EUDArray(1000);
const monster_spawn_y = EUDArray(1000);
const chunk_spawns = EUDArray(256);
const chunk_buffer = EUDArray(8);

var time = 0;
var test_delay = 0;

object Vector2 {
    var x, y;
    function constructor(x, y) {
        this.x = x;
        this.y = y;
    }
};


function CenterLoc(location, x, y) {
    setloc(L_MAIN, x, y);
    MoveLocation(location, $U("Map Revealer"), $P12, L_MAIN);
}

function CenterLocHero(location, playerID) {
    MoveLocation(location, U_HERO, playerID, L_ANYWHERE);
}

function EnemiesAtLoc(location) {
    if (Bring(Foes, AtLeast, 1, U_ANY, location)) return 1;
    return 0;
}

function GetVision(playerID) {
    if (playerID == 0) RunAIScript("+Vi0");
    else if (playerID == 1) RunAIScript("+Vi1");
    else if (playerID == 2) RunAIScript("+Vi2");
    else if (playerID == 3) RunAIScript("+Vi3");
    else if (playerID == 4) RunAIScript("+Vi4");
    else if (playerID == 5) RunAIScript("+Vi5");
    else if (playerID == 6) RunAIScript("+Vi6");
    else if (playerID == 7) RunAIScript("+Vi7");
}

function LoseVision(playerID) {
    if (playerID == 0) RunAIScript("-Vi0");
    else if (playerID == 1) RunAIScript("-Vi1");
    else if (playerID == 2) RunAIScript("-Vi2");
    else if (playerID == 3) RunAIScript("-Vi3");
    else if (playerID == 4) RunAIScript("-Vi4");
    else if (playerID == 5) RunAIScript("-Vi5");
    else if (playerID == 6) RunAIScript("-Vi6");
    else if (playerID == 7) RunAIScript("-Vi7");
}

function GetLocationPoint(location) {
	const locTable = EPD(0x58DC4C);
	return dwread_epd(locTable + location * 5), dwread_epd(locTable + location * 5 + 1);
}

function StoreSpawnPositions() {
    var i = 0;
    foreach(unit : EUDLoopCUnit()) {
        if (unit.playerID == $P9) {
            monster_spawn_type[i] = unit.unitType;
            monster_spawn_x[i] = unit.posX;
            monster_spawn_y[i] = unit.posY;
            unit.remove();
            i++;
        }
    }
}

function GetChunkID(chunkX, chunkY) {
    if (chunkX >= 0 && chunkX < 256 && chunkY >= 0 && chunkY < 256) {
        return (chunkX + (chunkY * 256)) + 1;
    }
    // printAll("ERROR: INVALID CHUNK COORDINATES!");
    return 0;
}

function GetChunkCoords(chunkID) {
    var chunkY, chunkX = div(chunkID - 1, 256);
    if (chunkX >= 0 && chunkX < 256 && chunkY >= 0 && chunkY < 256) {
        return chunkX, chunkY;
    }
    // printAll("ERROR: INVALID CHUNK COORDINATES FROM ID!");
    return 1000, 1000;
}

function FillChunkBuffer(chunkX, chunkY) {
    // returns an array of ids of the 8 surrounding chunks, ids are zero if not valid like at the edge of the map
    // starts top and goes clockwise. Fills global chunk buffer.
    for (var i = 0; i < 8; i++) chunk_buffer[i] = 0;
    chunk_buffer[0] = GetChunkID(chunkX, chunkY - 1);
    chunk_buffer[1] = GetChunkID(chunkX + 1, chunkY - 1);
    chunk_buffer[2] = GetChunkID(chunkX + 1, chunkY);
    chunk_buffer[3] = GetChunkID(chunkX + 1, chunkY + 1);
    chunk_buffer[4] = GetChunkID(chunkX, chunkY + 1);
    chunk_buffer[5] = GetChunkID(chunkX - 1, chunkY + 1);
    chunk_buffer[6] = GetChunkID(chunkX - 1, chunkY);
    chunk_buffer[7] = GetChunkID(chunkX - 1, chunkY - 1);
}

function SpawnUnitsAtChunk(chunkX, chunkY) {
    const limit_left = (chunkX * 16) * 32;
    const limit_right = limit_left + 512;
    const limit_top = (chunkY * 16) * 32;
    const limit_bottom = limit_top + 512;
    for (var i = 0; i < 1000; i++) {
        if (monster_spawn_x[i] >= limit_left && monster_spawn_x[i] < limit_right && monster_spawn_y[i] >= limit_top && monster_spawn_y[i] < limit_bottom) {
            if (monster_spawn_type[i] > 0) {
                setloc(L_MAIN, monster_spawn_x[i], monster_spawn_y[i]);
                CreateUnit(1, monster_spawn_type[i], L_MAIN, $P7);
            }
        }
    }
    chunk_spawns[GetChunkID(chunkX, chunkY)] += 1;
}

function JustEnteredChunk(chunkX, chunkY) {
    // const id = GetChunkID(chunkX, chunkY);
    // const x, y = GetChunkCoords(id);
    // eprintf("original coords: {} {} | id: {} | converted coords: {} {}", chunkX, chunkY, id, x, y);
    FillChunkBuffer(chunkX, chunkY);
    for (var i = 0; i < 8; i++) {
        if (chunk_buffer[i] > 0 && chunk_spawns[chunk_buffer[i]] == 0) {
            const x, y = GetChunkCoords(chunk_buffer[i]);
            SpawnUnitsAtChunk(x, y);
        }
    }
}

function GetChunkAtPos(positionX, positionY) {
    var chunk_pos_x = (positionX / 32) / 16;
    var chunk_pos_y = (positionY / 32) / 16;
    return chunk_pos_x, chunk_pos_y;
}

function CreateCUnit(unitType, playerID, location) : CUnit {
	const newUnit = CUnit.from_read(EPD(0x628438));
	CreateUnit(1, unitType, location, playerID);
	return newUnit;
}

function Is_Alive(playerID) {
    if (Command(playerID, AtLeast, 1, U_HERO)) return true;
    return false;
}

function CreateImageSpriteAtLocation(imageID, location) {
    const new_script = 281;
    const prev_script = dwread(0x666778 + 34000 + imageID * 4);
    dwwrite(0x666778 + 34000 + imageID * 4, new_script);
	SetMemoryX(0x00666458, SetTo, imageID, 0x0000ffff);
	CreateUnit(1, 33, location, $P8);
	RemoveUnit(33, AllPlayers);
	SetMemoryX(0x00666458, SetTo, 546, 0x0000ffff);
    dwwrite(0x666778 + 34000 + imageID * 4, prev_script);
}

function CreateUnitDeathAtLocation(Unit, playerID, location) {
    CreateUnit(1, Unit, location, playerID);
    KillUnit(Unit, playerID);
}

function DamageUnit(unit:CUnit, damage) {
	if (unit.hp < damage * 256) unit.hp = 0;
	if (unit.hp == 0) unit.die();
	else unit.hp -= damage * 256;
}

function GetAngle(originx, originy, destinationx, destinationy) {
    const angle = atan2(destinationy - originy, destinationx - originx);
    return angle;
}

function AddAngles(angle0, angle1) {
    var new_angle = angle0 + angle1;
    if (new_angle > 4000000000) new_angle += 359;
    else if (new_angle > 359) new_angle -= 359;
    return new_angle;
}

function MoveVectorTowards(positionx, positiony, angle, distance) {
    const directionx, directiony = lengthdir(distance, angle);
    const new_positionx = positionx + directionx;
    const new_positiony = positiony + directiony;
    return new_positionx, new_positiony;
}

function Random(min, max) {
   return min + dwrand() / (4294967295 / (max - min + 1) + 1);
}

const PROJECTILE_POOL = 192;
const pro_posx = EUDArray(PROJECTILE_POOL);
const pro_posy = EUDArray(PROJECTILE_POOL);
const pro_time = EUDArray(PROJECTILE_POOL);
const pro_maxtime = EUDArray(PROJECTILE_POOL);
const pro_angle = EUDArray(PROJECTILE_POOL);
const pro_velocity = EUDArray(PROJECTILE_POOL);
const pro_angular_velocity = EUDArray(PROJECTILE_POOL);
const pro_orbit = EUDArray(PROJECTILE_POOL);
const pro_orbit_velocity = EUDArray(PROJECTILE_POOL);
const pro_orbit_dist = EUDArray(PROJECTILE_POOL);
const pro_image0 = EUDArray(PROJECTILE_POOL);
const pro_image0_start = EUDArray(PROJECTILE_POOL);
const pro_image1 = EUDArray(PROJECTILE_POOL);
const pro_image1_start = EUDArray(PROJECTILE_POOL);
const pro_image2 = EUDArray(PROJECTILE_POOL);
const pro_image2_start = EUDArray(PROJECTILE_POOL);

function ResetProjectile(i) {
    pro_time[i] = 0;
    pro_maxtime[i] = 0;
    pro_posx[i] = 0;
    pro_posy[i] = 0;
    pro_angle[i] = 0;
    pro_velocity[i] = 0;
    pro_angular_velocity[i] = 0;
    pro_orbit[i] = 0;
    pro_orbit_velocity[i] = 0;
    pro_orbit_dist[i] = 0;
    pro_image0[i] = 0;
    pro_image0_start[i] = 0;
    pro_image1[i] = 0;
    pro_image1_start[i] = 0;
    pro_image2[i] = 0;
    pro_image2_start[i] = 0;
}

var queue_pro_posx = 0;
var queue_pro_posy = 0;
var queue_pro_time = 0;
var queue_pro_maxtime = 0;
var queue_pro_angle = 0;
var queue_pro_velocity = 0;
var queue_pro_angular_velocity = 0;
var queue_pro_orbit = 0;
var queue_pro_orbit_velocity = 0;
var queue_pro_orbit_dist = 0;
var queue_pro_image0 = 0;
var queue_pro_image0_start = 0;
var queue_pro_image1 = 0;
var queue_pro_image1_start = 0;
var queue_pro_image2 = 0;
var queue_pro_image2_start = 0;
function ResetProjectileQueue() {
    queue_pro_posx = 0;
    queue_pro_posy = 0;
    queue_pro_time = 0;
    queue_pro_maxtime = 0;
    queue_pro_angle = 0;
    queue_pro_velocity = 0;
    queue_pro_angular_velocity = 0;
    queue_pro_orbit = 0;
    queue_pro_orbit_velocity = 0;
    queue_pro_orbit_dist = 0;
    queue_pro_image0 = 0;
    queue_pro_image0_start = 0;
    queue_pro_image1 = 0;
    queue_pro_image1_start = 0;
    queue_pro_image2 = 0;
    queue_pro_image2_start = 0;
}

function CreateProjectile() {
    for (var i = 0; i < PROJECTILE_POOL; i++) {
        if (pro_time[i] == 0) {
            pro_time[i] = 1;
            pro_maxtime[i] = queue_pro_maxtime;
            pro_posx[i] = queue_pro_posx;
            pro_posy[i] = queue_pro_posy;
            pro_angle[i] = queue_pro_angle;
            pro_velocity[i] = queue_pro_velocity;
            pro_angular_velocity[i] = queue_pro_angular_velocity;
            pro_orbit[i] = queue_pro_angle;
            pro_orbit_velocity[i] = queue_pro_orbit_velocity;
            pro_orbit_dist[i] = queue_pro_orbit_dist;
            pro_image0[i] = queue_pro_image0;
            pro_image0_start[i] = queue_pro_image0_start;
            pro_image1[i] = queue_pro_image1;
            pro_image1_start[i] = queue_pro_image1_start;
            pro_image2[i] = queue_pro_image2;
            pro_image2_start[i] = queue_pro_image2_start;
            ResetProjectileQueue();
            break;
        }
    }
}

function UpdateProjectiles() {
    for (var i = 0; i < PROJECTILE_POOL; i++) {
        if (pro_time[i] > 0) {
            pro_time[i] += 1;
            pro_angle[i] = AddAngles(pro_angle[i], pro_angular_velocity[i]);
            const new_posx, new_posy = MoveVectorTowards(pro_posx[i], pro_posy[i], pro_angle[i], pro_velocity[i]);
            pro_posx[i] = new_posx;
            pro_posy[i] = new_posy;

            pro_orbit[i] = AddAngles(pro_orbit[i], pro_orbit_velocity[i]);
            const offsetx, offsety = MoveVectorTowards(new_posx, new_posy, pro_orbit[i], pro_orbit_dist[i]);
            setloc(L_MAIN, offsetx, offsety);
            //IMAGES
            if (pro_time[i] >= pro_image0_start[i] && pro_time[i] < pro_image1_start[i]) {
                // time for image 0
                CreateImageSpriteAtLocation(pro_image0[i], L_MAIN);
            } else if (pro_time[i] >= pro_image1_start[i] && pro_time[i] < pro_image2_start[i]) {
                // time for image 1
                CreateImageSpriteAtLocation(pro_image1[i], L_MAIN);
            } else if (pro_time[i] >= pro_image2_start[i]) {
                // time for image 2
                CreateImageSpriteAtLocation(pro_image2[i], L_MAIN);
            }

            if (pro_time[i] >= pro_maxtime[i]) {
                ResetProjectile(i);
            }
        }
    }
}

// GAME LOGIC
function onPluginStart() {
    StoreSpawnPositions();
    EUDPlayerLoop()();
        const PID = getcurpl();
        p_armor_max[PID] = 1000 * 256;
        p_damage[PID] = 20;
        GetVision($P8);
        if (Command(PID, AtLeast, 1, U_HERO)) {
            MoveLocation(L_MAIN, U_HERO, PID, L_ANYWHERE);
            RemoveUnit(U_HERO, PID);
            p_cunit[PID] = CreateCUnit(U_HERO, PID, L_MAIN);
            CenterView(L_MAIN);
        }
    EUDEndPlayerLoop();
}
var test_value = 0;
var test_value0 = 0;
function afterTriggerExec() {
    time += 1;
    UpdateProjectiles();
    EUDPlayerLoop()();
        const PID = getcurpl();
        if (PID >= 0 && PID < 6) {
            const unit = CUnit(p_cunit[PID]);
            var order_input = 0;
            var unit_is_moving = 0;
            var unit_just_attacked = 0;
            if (unit.orderID == ORDER_HOLD || unit.orderID == ORDER_PATROL) {
                order_input = unit.orderID;
                unit.orderID = 3;
            }
            if (unit.posX == p_pos_x_old[PID] && unit.posY == p_pos_y_old[PID]) {
                unit_is_moving = 0;
            } else {
                p_pos_x_old[PID] = unit.posX;
                p_pos_y_old[PID] = unit.posY;
                unit_is_moving = 1;
            }
            if (!unit_is_moving && unit.currentSpeed1 > 0) {
                unit.currentSpeed1 = 0; // Unit stuck because of flingy movement fix.
                unit.currentSpeed2 = 0;
            }
            if (unit_is_moving) {
                const x, y = GetChunkAtPos(unit.posX, unit.posY);
                if (p_chunk_x_old[PID] != x || p_chunk_y_old[PID] != y) {
                    p_chunk_x_old[PID] = x;
                    p_chunk_y_old[PID] = y;
                    JustEnteredChunk(x, y);
                }
            }

            // ARMOR
            if (Is_Alive(PID)) {
                CenterLocHero(L_16x16, PID);
                CenterLocHero(L_3X3, PID);
                if (p_armor_max[PID] > 0 && EnemiesAtLoc(L_16x16)) {
                    if (EnemiesAtLoc(L_3X3) && p_armor_recover[PID] == 0) p_armor_recover[PID] = 1;
                } else {
                    if (unit.shield < p_armor_max[PID]) unit.shield += 10 * 256;
                    if (unit.shield > p_armor_max[PID]) unit.shield = p_armor_max[PID];
                }
                if (!EnemiesAtLoc(L_3X3) && p_armor_recover[PID] > 0) {
                    p_armor_recover[PID] = 0;
                    unit.shield = p_armor_max[PID];
                    CreateImageSpriteAtLocation(377, L_3X3);
                    PlayWAV("staredit/wav/dodge.ogg");
                }
            }

            // UNIT ATTACK
            if (Is_Alive(PID)) {
                if (unit.groundWeaponCooldown == 26) {
                    unit.groundWeaponCooldown -= p_attackspeed[PID];
                    DamageUnit(unit.orderTargetUnit, p_damage[PID]);
                    unit_just_attacked = 1;
                }
            }

            if (unit_just_attacked) {
                DisplayText("attacked.");
            }

            if (test_delay == 0) {
                test_delay = 2;
                queue_pro_angle = Random(0, 359);
                queue_pro_velocity = Random(10, 50);
                queue_pro_posx, queue_pro_posy = unit.posX, unit.posY;
                queue_pro_maxtime = 48;
                queue_pro_angular_velocity = test_value;
                queue_pro_image0 = 443;
                queue_pro_image0_start = 0;
                queue_pro_image1 = 523;
                queue_pro_image1_start = 24;
                queue_pro_image2 = 427;
                queue_pro_image2_start = 36;
                CreateProjectile();
            }
            test_delay -= 1;

            if (order_input == ORDER_HOLD) {
                test_value -= 2;
            } 
            else if (order_input == ORDER_PATROL) {
                test_value += 2;
            }
            eprintf("{} {}", test_value, test_value0);
        }
    EUDEndPlayerLoop();
}