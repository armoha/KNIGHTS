// @bm CONSTANTS
const L_ANYWHERE = $L("Anywhere");
const L_MAIN = $L("main");
const L_0x0 = $L("0x0");
const L_3X3 = $L("3x3");
const L_4x4 = $L("4x4");
const L_16x16 = $L("16x16");
const L_PLAYER = [4, 5, 6, 7, 8, 9];
const L_MOUSE = [16, 17, 18, 19, 20, 21];
const L_CHECK = $L("check");
const L_HEIGHT0 = $L("height0");
const L_HEIGHT1 = $L("height1");
const L_HEIGHT2 = $L("height2");

const U_HERO = [61, 62, 64, 12, 60, 86];
const U_CHIMERA = 37;
const U_HILL_SPINT = 38;
const U_GUARDIAN_ANGEL = 68;
const U_ANY = 229;
const U_KAKARU = 94;
const U_SCOURGE = 47;
const U_WEAPON = 129;
const U_ARMOR = 219;
const U_UTILITY = 128;
const U_MARKER = 7; // P10 = WEAPON, P11 = ARMOR, P12 = SPECIAL
const U_EXPERIENCE = 220;
const U_CHECKHEIGHT = 9;
const U_PATHABLE = 0;
const U_LIFEPICKUP = 106;

const NPC_GUARDIAN_ANGEL = 1;

const ORDER_HOLD = 107;
const ORDER_PATROL = 152;

const ISCRIPT_NORMAL = 281;
const ISCRIPT_FAST = 286;
const ISCRIPT_LONGFAST = 392;

const IMAGE_ZERG_AIR_DEATH_SMALL = 59;
const IMAGE_PLAGUE_CLOUD = 387;
const IMAGE_HALLUC_DEATH1 = 557;
const IMAGE_EXPL_BLUE_SMALL = 213;
const IMAGE_SCOURGE_ATTACK = 4;
const IMAGE_LONGBOLT_TRAIL = 422;
const IMAGE_FRAG_GRENADE_HIT = 440;
const IMAGE_LIGHTNING_STORM = 525;
const IMAGE_LIGHTNING0 = 550;
const IMAGE_LIGHTNING1 = 551;
const IMAGE_LIGHTNING2 = 552;
const IMAGE_LIGHTNING3 = 553;
const IMAGE_NUKE_DOT = 233;
const IMAGE_PHOTON_BLASTERS = 519;
const IMAGE_PARTICLE_BEAM = 520;
const IMAGE_SCARAB_MISSILE = 443;

const FULL_DAY_LENGTH = 8640;
const BRIGHTNESS_DEFAULT = 31;
const BRIGHTNESS_NIGHT = 25;
const ELEVATION_DEFAULT = 4;
const ACTIVE_UNITS_MAX = 40;
const ACTIVE_UNITS_RECT = 960;
const MAX_MONSTER_SPAWNS = 1000;
const MAX_SIGIL_SPAWNS = 10;
const MAX_WORLD_INTERACTIONS = 10;
const SIGIL_DIAMETER = 128;
const CLOSE_LOOT_MENU_DISTANCE = 64;

const MENU_MAIN_SIGIL = 1;

const PLAYER_DEFAULT_HP = 100;
const PLAYER_DEFAULT_SIGHT = 8;
const PLAYER_DEFAULT_SHIELD = 0;
const PLAYER_DEFAULT_DAMAGE = 6;
const PLAYER_DEFAULT_ATTRIBUTE = 1;
const PLAYER_LIFE_PICKUP_INCREASE = 20 * 256;

const WEAPON_SHORTSWORD = 1;
const WEAPON_SHORTBOW = 2;
const WEAPON_FIREBALL = 3;
const WEAPON_ANCIENT_TOME_OF_STARFALL = 4;
const WEAPON_LONGSWORD = 5;
const WEAPON_GREATSWORD = 6;
const WEAPON_LONGBOW = 7;
const WEAPON_GREATBOW = 8;
const WEAPON_LIGHTNINGBLAST = 9;
const WEAPON_BLADESTORM = 10;
// const WEAPON_CRIMSON_LONG_SWORD = 5;

const UTILITY_DASH = 1;

const ARMOR_SHATTERED_KNIGHTS = 1;
// const ARMOR_CRIMSON_ENGRAVED_PLATE = 2;

const CHIMERA_EXP = 30;

const STRING_WEAPON_DAMAGE = Db("\x12\x04Weapon Damage: \x06");

const keypress_1 = PVariable();
const keypress_2 = PVariable();
const keypress_3 = PVariable();
const keypress_4 = PVariable();
const keypress_5 = PVariable();
const keypress_6 = PVariable();
const keypress_7 = PVariable();
const keypress_8 = PVariable();
const keypress_9 = PVariable();
const keypress_0 = PVariable();
const keypress_f = PVariable();
EUDRegisterObjectToNamespace("key_1", keypress_1);
EUDRegisterObjectToNamespace("key_2", keypress_2);
EUDRegisterObjectToNamespace("key_3", keypress_3);
EUDRegisterObjectToNamespace("key_4", keypress_4);
EUDRegisterObjectToNamespace("key_5", keypress_5);
EUDRegisterObjectToNamespace("key_6", keypress_6);
EUDRegisterObjectToNamespace("key_7", keypress_7);
EUDRegisterObjectToNamespace("key_8", keypress_8);
EUDRegisterObjectToNamespace("key_9", keypress_9);
EUDRegisterObjectToNamespace("key_0", keypress_0);
EUDRegisterObjectToNamespace("key_f", keypress_f);

const strings_loot_interactions = EUDArray(10);

// @bm PLAYER VARS
const p_cunit = PVariable(); // holds the cunit pointer of the players unit
const p_x = PVariable(); // coordinates of the unit
const p_y = PVariable();
const p_x_old = PVariable(); 
const p_y_old = PVariable();
const p_angle = PVariable(); // facing angle
const p_orderx = PVariable();
const p_ordery = PVariable();
const p_chunk_x_old = PVariable(); 
const p_chunk_y_old = PVariable();
const p_health = PVariable();
const p_health_max = PVariable();
const p_health_magic_drained = PVariable();
const p_shield = PVariable();
const p_shield_max = PVariable();
const p_shield_recover = PVariable();
const p_shield_broken = PVariable();
const p_damage = PVariable(); // damage of the unit attack
const p_brightness = PVariable();
const p_exp_current = PVariable();
const p_exp_buffer = PVariable();
const p_exp_goal = PVariable();
const p_exp_total = PVariable();
const p_exp_x = PVariable();
const p_exp_y = PVariable();
const p_exp_lost = PVariable();
const p_exp_lost_timer = PVariable();
const p_level_current = PVariable();
const p_armor = PVariable();
const p_homepos_x = PVariable();
const p_homepos_y = PVariable();
const p_indoors = PVariable();
const p_strength = PVariable();
const p_dexterity = PVariable();
const p_resilience = PVariable();
const p_attributepoints = PVariable();
const p_on_sigil = PVariable();
const p_current_sigil = PVariable();
const p_current_item_unit = PVariable();
const p_just_attacked = PVariable();
const p_order_input = PVariable();
const p_death_state = PVariable();
const p_on_world_interaction = PVariable();
const p_interaction_prompt_delay = PVariable();
var p_current_death_hint = 0;

const MAX_NPC_UNITS = 30;
const npc_x = EUDArray(MAX_NPC_UNITS);
const npc_y = EUDArray(MAX_NPC_UNITS);
const npc_home_x = EUDArray(MAX_NPC_UNITS);
const npc_home_y = EUDArray(MAX_NPC_UNITS);
const npc_id = EUDArray(MAX_NPC_UNITS);
const npc_cunit = EUDArray(MAX_NPC_UNITS);
const npc_state0 = EUDArray(MAX_NPC_UNITS);
const npc_state1 = EUDArray(MAX_NPC_UNITS);
const npc_state3 = EUDArray(MAX_NPC_UNITS);
const npc_order_timer = EUDArray(MAX_NPC_UNITS);

const MAX_WEAPON_OBJECTS = 6 + 50;
const weapon_cunit = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_id = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_state = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_cooldown = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_angle = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_x = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_y = EUDArray(MAX_WEAPON_OBJECTS);

const MAX_UTILITY_OBJECTS = 6 + 50;
const utility_cunit = EUDArray(MAX_UTILITY_OBJECTS);
const utility_id = EUDArray(MAX_UTILITY_OBJECTS);
const utility_state = EUDArray(MAX_UTILITY_OBJECTS);
const utility_cooldown = EUDArray(MAX_UTILITY_OBJECTS);
const utility_x = EUDArray(MAX_UTILITY_OBJECTS);
const utility_y = EUDArray(MAX_UTILITY_OBJECTS);
const utility_angle = EUDArray(MAX_UTILITY_OBJECTS);

const m_main = PVariable();
const m_page = PVariable();

const screen = StringBuffer();
const monster_spawn_type = EUDArray(MAX_MONSTER_SPAWNS);
const monster_spawn_x = EUDArray(MAX_MONSTER_SPAWNS);
const monster_spawn_y = EUDArray(MAX_MONSTER_SPAWNS);
const sigil_x = EUDArray(MAX_SIGIL_SPAWNS);
const sigil_y = EUDArray(MAX_SIGIL_SPAWNS);
const sigil_glow = EUDArray(MAX_SIGIL_SPAWNS);
const world_interaction_x = EUDArray(MAX_WORLD_INTERACTIONS);
const world_interaction_y = EUDArray(MAX_WORLD_INTERACTIONS);
const world_interaction_size = EUDArray(MAX_WORLD_INTERACTIONS);
const chunk_spawns = EUDArray(256);
const chunk_buffer = EUDArray(8);
const active_units = EUDArray(ACTIVE_UNITS_MAX * 6);
var active_units_update = 0;
// @bm DEBUG MODE
var debug_enabled = 1;
const debug_values = EUDArray(8);
var time = 0;
var total_time = 0;
var time_state = 0;
var time_state_changed = 0;
var days_elapsed = 0;
var experience_ping_timer = 0;
var cunit_pathable = 0;
var cunit_checkheight = 0;

const field_puzzle_state = EUDArray(3);
const field_puzzle_state_solution = EUDArray(3);


function isAlly(p: TrgPlayer, tgp: TrgPlayer) {
    const q, r = div(tgp, 4);
    const epd = EPD(0x58D634) + q + (3 * p);
    var bitmask;
    switch (r, 3) {
        case 0: bitmask = 3 << 0; break;
        case 1: bitmask = 3 << 8; break;
        case 2: bitmask = 3 << 16; break;
        case 3: bitmask = 3 << 24; break;
    }
    return l2v(MemoryXEPD(epd, AtLeast, 1, bitmask));
}

function PlaySong(id) {
    if (id == 0) PlayWAV("staredit/wav/song0.ogg");
}

function PlaySword() {
    const sound = Random(1, 4);
    if (sound == 1) PlayWAV("staredit/wav/sword1.ogg");
    else if (sound == 2) PlayWAV("staredit/wav/sword2.ogg");
    else if (sound == 3) PlayWAV("staredit/wav/sword3.ogg");
    else if (sound == 4) PlayWAV("staredit/wav/sword4.ogg");
}

function PlayArrow() {
    const sound = Random(1, 4);
    if (sound == 1) PlayWAV("staredit/wav/arrow1.ogg");
    else if (sound == 2) PlayWAV("staredit/wav/arrow2.ogg");
    else if (sound == 3) PlayWAV("staredit/wav/arrow3.ogg");
    else if (sound == 4) PlayWAV("staredit/wav/arrow4.ogg");
}

function GetStringItemName(item_id, unitID) {
    if (unitID == U_WEAPON) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case WEAPON_SHORTSWORD: return Db("Short Sword");
            case WEAPON_SHORTBOW: return Db("Short Bow");
            case WEAPON_FIREBALL: return Db("Tome Of Fireball");
            case WEAPON_ANCIENT_TOME_OF_STARFALL: return Db("Ancient Tome Of Starfall");
            case WEAPON_LONGSWORD: return Db("Long Sword");
            case WEAPON_GREATSWORD: return Db("Great Sword");
            case WEAPON_LONGBOW: return Db("Long Bow");
            case WEAPON_GREATBOW: return Db("Great Bow");
            case WEAPON_LIGHTNINGBLAST: return Db("Tome Of Lightning Blast");
            case WEAPON_BLADESTORM: return Db("Tome Of Blade Storm");
	    }
    } else if (unitID == U_ARMOR) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case ARMOR_SHATTERED_KNIGHTS: return Db("Shattered Knight's Armor");
        }
    }
}

function GetStringItemDescription(item_id, unitID) {
    if (unitID == U_WEAPON) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case WEAPON_SHORTSWORD: return Db("A basic sword meant for utility and consistency.");
            case WEAPON_SHORTBOW: return Db("A basic ranger's bow, appreciated for its swiftness.");
            case WEAPON_FIREBALL: return Db("An old, common, and lethal, magical writing.");
            case WEAPON_ANCIENT_TOME_OF_STARFALL: return Db("An ancient secret weapon passed down to only the most legendary ranks.");
            case WEAPON_LONGSWORD: return Db("An agile and weighty sword.");
            case WEAPON_GREATSWORD: return Db("A slow and powerful sword.");
            case WEAPON_LONGBOW: return Db("A bow with medium range and effectiveness.");
            case WEAPON_GREATBOW: return Db("A massive bow with immense velocity.");
            case WEAPON_LIGHTNINGBLAST: return Db("Call upon sparks of energy to destroy foes.");
            case WEAPON_BLADESTORM: return Db("A deadly art intended for close combat.");
	    }
    } else if (unitID == U_ARMOR) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case ARMOR_SHATTERED_KNIGHTS: return Db("Some damaged old armor from another life.");
        }
    }
}

function GetStringHint(id) {
    switch(id) {
        case 0: return Db("Don't forget to dodge in combat. Dodging is when you recover your armor by backing away from foes.");
        case 1: return Db("Only aggravate as many enemies as you can handle.");
        case 2: return Db("The penalty for death is dropping your current experience. Which you can recover if you reach it in time.");
        case 3: return Db("hint");
        case 4: return Db("hint");
        case 5: return Db("hint");
        case 6: return Db("hint");
        case 7: return Db("hint");
        case 8: return Db("hint");
        case 9: return Db("hint");
        case 10: return Db("hint");
	}
}

function GetStringWorldInteractionPrompt(id) {
    switch(id) {
        case 0, 1, 2: return Db("\x13\x04Press \x03-<1>- \x04to Examine the Pillar.\n\x13\x04Press \x03-<2>- \x04to Spin the Talisman.");
        case 3: return Db("hint");
        case 4: return Db("hint");
        case 5: return Db("hint");
        case 6: return Db("hint");
        case 7: return Db("hint");
        case 8: return Db("hint");
        case 9: return Db("hint");
        case 10: return Db("hint");
	}
}

function SetupStringArrays() {
    strings_loot_interactions[0] = Db("\x03-<1>- \x04to Equip.");
    strings_loot_interactions[1] = Db("\x03-<1>- \x04to Equip and swap with: ");
}

function SetupSystemUnits() {
    cunit_checkheight = CUnit.from_read(EPD(0x628438));
    CreateUnitWithProperties(1, U_CHECKHEIGHT, L_CHECK, $P8, UnitProperty(invincible = true));
    GiveUnits(1, U_CHECKHEIGHT, $P8, L_ANYWHERE, $P12);
    cunit_pathable = CUnit.from_read(EPD(0x628438));
    CreateUnitWithProperties(1, U_PATHABLE, L_CHECK, $P8, UnitProperty(invincible = true));
    GiveUnits(1, U_PATHABLE, $P8, L_ANYWHERE, $P12);
}

function SetupWorldInteractions() {
    world_interaction_x[0], world_interaction_y[0] = 3160, 1840; world_interaction_size[0] = 128;
    world_interaction_x[1], world_interaction_y[1] = 3176, 2800; world_interaction_size[1] = 128;
    world_interaction_x[2], world_interaction_y[2] = 1976, 2672; world_interaction_size[2] = 128;
}

function GetWholeAndFraction(value) {
    // takes in a value * 10000 and returns the whole numbers + the fraction separately.
    var new_value = value;
    const whole = value / 10000;
    new_value -= (10000 * whole);
    const fraction = new_value;
    return whole, fraction;
}

function GetHealthToughnessDeduction(playerID, damage_amount) {
    // every point of dexterity = 2% damage reduced to the damage_amount.
    const percent_deducted = (p_dexterity[playerID] * 2) * 100;
    const deduction = (damage_amount * percent_deducted) / 10000;
    return deduction;
}

function GetArmorToughnessDeduction(playerID, damage_amount) {
    // every point of resilience = 2% damage reduced to the damage_amount.
    const percent_deducted = (p_resilience[playerID] * 2) * 100;
    const deduction = (damage_amount * percent_deducted) / 10000;
    return deduction;
}

function GetAttackSpeed(playerID) {
    var value = p_dexterity[playerID];
    if (value > 20) value = 20;
    return value;
}

function CalculateKnightSwordDamage(playerID) {
    p_damage[playerID] = PLAYER_DEFAULT_DAMAGE + (p_strength[playerID] * 3);
}

function GetHealthRegen(playerID) { // 2 per frame = 0.1875 per second
    var regen = 2 * (p_strength[playerID] / 2);
    var magic_drain_rate = 4 * p_resilience[playerID];
    if (p_health_magic_drained[playerID] >= magic_drain_rate) {
        regen += magic_drain_rate;
        p_health_magic_drained[playerID] -= magic_drain_rate;
    } else if (p_health_magic_drained[playerID] > 0) {
        regen += p_health_magic_drained[playerID];
        p_health_magic_drained[playerID] = 0;
    }
    return regen;
}

function GetWeaponCooldown(item_id) {
    if (item_id == WEAPON_SHORTSWORD) return 96;
    else if (item_id == WEAPON_SHORTBOW) return 36;
    else if (item_id == WEAPON_FIREBALL) return 48;
    else if (item_id == WEAPON_ANCIENT_TOME_OF_STARFALL) return 24;
    else if (item_id == WEAPON_LONGSWORD) return 48;
    else if (item_id == WEAPON_GREATSWORD) return 48;
    else if (item_id == WEAPON_LONGBOW) return 48;
    else if (item_id == WEAPON_GREATBOW) return 48;
    else if (item_id == WEAPON_LIGHTNINGBLAST) return 48; // 120
    else if (item_id == WEAPON_BLADESTORM) return 48;
}

function GetWeaponDamage(item_id, state, playerID) { // in the future could make unit an argument so that can have different damage based on unitid
    var damage = 0;
    if (playerID >= 0 && playerID <= 5) {
        if (item_id == WEAPON_SHORTSWORD) damage = 6 + (1 * p_strength[playerID]);
        else if (item_id == WEAPON_SHORTBOW) damage = 10 + (2 * p_dexterity[playerID]);
        else if (item_id == WEAPON_FIREBALL) damage = 4 + (2 * p_resilience[playerID]);
        else if (item_id == WEAPON_ANCIENT_TOME_OF_STARFALL) damage = 50 + (5 * p_resilience[playerID]);
        else if (item_id == WEAPON_LONGSWORD) damage = 6 + (1 * p_strength[playerID]);
        else if (item_id == WEAPON_GREATSWORD) damage = 6 + (1 * p_strength[playerID]);
        else if (item_id == WEAPON_LONGBOW) damage = 10 + (2 * p_dexterity[playerID]);
        else if (item_id == WEAPON_GREATBOW) damage = 10 + (2 * p_dexterity[playerID]);
        else if (item_id == WEAPON_LIGHTNINGBLAST && state == 0) damage = 8 + (2 * p_resilience[playerID]);
        else if (item_id == WEAPON_LIGHTNINGBLAST && state == 1) damage = 4 + (2 * p_resilience[playerID]);
        else if (item_id == WEAPON_BLADESTORM) damage = 4 + (2 * p_resilience[playerID]);
    } else if (playerID == $P7) {
        if (item_id == WEAPON_SHORTSWORD) damage = 30;
        else if (item_id == WEAPON_SHORTBOW) damage = 50;
        else if (item_id == WEAPON_FIREBALL) damage = 50;
        else if (item_id == WEAPON_ANCIENT_TOME_OF_STARFALL) damage = 5000;
        else if (item_id == WEAPON_LONGSWORD) damage = 50;
        else if (item_id == WEAPON_GREATSWORD) damage = 50;
        else if (item_id == WEAPON_LONGBOW) damage = 50;
        else if (item_id == WEAPON_GREATBOW) damage = 50;
        else if (item_id == WEAPON_LIGHTNINGBLAST) damage = 50;
        else if (item_id == WEAPON_BLADESTORM) damage = 50;
    }
    return damage;
}

function GetWeaponLifeCost(item_id, playerID) {
    var life_cost = 0;
    if (playerID > 5) return 0;
    if (item_id == WEAPON_FIREBALL) life_cost = 10 * 256;
    else if (item_id == WEAPON_LIGHTNINGBLAST) life_cost = 25 * 256;
    else if (item_id == WEAPON_ANCIENT_TOME_OF_STARFALL) life_cost = 99 * 256;
    return life_cost;
}

function CheckForWeaponTrigger(playerID, unit: CUnit, item_id) {
    var is_player = 0;
    var weapon_was_triggered = 0;
    var player_attack_clicked = 0;
    if (playerID < 6) is_player = 1;
    if ((is_player && unit.orderID == 14) || (is_player && unit.orderID == 10)) player_attack_clicked = 1;
    if (item_id == WEAPON_SHORTSWORD) {
        if (is_player && p_just_attacked[playerID] > 0) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.groundWeaponCooldown == 7) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_SHORTBOW) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.groundWeaponCooldown == 7) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_HILL_SPINT && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_FIREBALL) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.groundWeaponCooldown == 7) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_ANCIENT_TOME_OF_STARFALL) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_GUARDIAN_ANGEL && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_LONGSWORD) {
        if (is_player && p_just_attacked[playerID] > 0) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_GREATSWORD) {
        if (is_player && p_just_attacked[playerID] > 0) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_LONGBOW) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_GREATBOW) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_LIGHTNINGBLAST) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_BLADESTORM) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
    }
    return weapon_was_triggered;
    // WEAPON_LONGSWORD
    // WEAPON_GREATSWORD
    // WEAPON_LONGBOW
    // WEAPON_GREATBOW
    // WEAPON_LIGHTNINGBLAST
    // WEAPON_BLADESTORM
}

function GetUtilityCooldown(item_id) {
    if (item_id == UTILITY_DASH) return 24; // 144
}

function GetUtilityLifeCost(item_id, playerID) {
    var life_cost = 0;
    if (playerID > 5) return 0;
    if (item_id == UTILITY_DASH) life_cost = 10 * 256;
    return life_cost;
}

function CheckForUtilityTrigger(playerID, unit: CUnit, item_id) {
    var is_player = 0;
    var utility_was_triggered = 0;
    if (playerID < 6) is_player = 1;
    if (item_id == UTILITY_DASH) {
        if (is_player && p_order_input[playerID] == ORDER_PATROL) utility_was_triggered = 1;
    }
    return utility_was_triggered;
}

function AttachWeaponToUnit(unit_ptr, item_id) {
    for (var i = 6; i < MAX_WEAPON_OBJECTS; i++) {
        if (weapon_id[i] == 0) {
            weapon_id[i] = item_id;
            weapon_cunit[i] = unit_ptr;
            break;
        }
    }
}

function GetDistance(originx, originy, destx, desty) {
    const a = originx - destx;
    const b = originy - desty;
    const distance = sqrt( a*a + b*b );
    return distance;
}

function CenterLoc(location, x, y) {
    setloc(L_MAIN, x, y);
    MoveLocation(location, $U("Map Revealer"), $P12, L_MAIN);
}

function CenterLocHero(location, playerID) {
    MoveLocation(location, U_HERO[playerID], playerID, L_ANYWHERE);
}

function HeroIsAt(location, playerID) {
    if (Bring(playerID, AtLeast, 1, U_HERO[playerID], location)) return 1;
    return 0;
}

function EnemiesAtLoc(location) {
    if (Bring(Foes, AtLeast, 1, U_ANY, location)) return 1;
    return 0;
}

function StandingOnSigil(positionx, positiony) {
    for (var i = 0; i < MAX_SIGIL_SPAWNS; i++) {
        if (sigil_x[i] > 0) {
            const dist = GetDistance(positionx, positiony, sigil_x[i], sigil_y[i]);
            if (dist <= 64) return i;
        }
    }
    return MAX_SIGIL_SPAWNS + 1;
}

function CreateCUnit(unitType, playerID, location) : CUnit {
	const newUnit = CUnit.from_read(EPD(0x628438));
	CreateUnit(1, unitType, location, playerID);
	return newUnit;
}

function CreateItemUnit(unitType, item_id, location) {
    const new_unit = CUnit(CreateCUnit(unitType, $P8, location));
    new_unit.energy = item_id;
    new_unit.shield = 1000;
}

function MakeUnitNPC(unit: CUnit, unitType) {
    var new_id = 0;
    if (unitType == U_GUARDIAN_ANGEL) new_id = NPC_GUARDIAN_ANGEL;
    else return; // do not let any data enter the array if the unitType is not valid.
    for (var i = 0; i < MAX_NPC_UNITS; i++) {
        if (npc_id[i] == 0) {
            npc_cunit[i] = unit;
            npc_id[i] = new_id;
            npc_home_x[i] = unit.posX;
            npc_home_y[i] = unit.posY;
            break;
        }
        if (i == MAX_NPC_UNITS - 1) {
            DisplayTextAll("ALERT: MAX NPCS REACHED");
        }
    }
}

function GetVision(playerID) {
    if (playerID == 0) RunAIScript("+Vi0");
    else if (playerID == 1) RunAIScript("+Vi1");
    else if (playerID == 2) RunAIScript("+Vi2");
    else if (playerID == 3) RunAIScript("+Vi3");
    else if (playerID == 4) RunAIScript("+Vi4");
    else if (playerID == 5) RunAIScript("+Vi5");
    else if (playerID == 6) RunAIScript("+Vi6");
    else if (playerID == 7) RunAIScript("+Vi7");
}

function LoseVision(playerID) {
    if (playerID == 0) RunAIScript("-Vi0");
    else if (playerID == 1) RunAIScript("-Vi1");
    else if (playerID == 2) RunAIScript("-Vi2");
    else if (playerID == 3) RunAIScript("-Vi3");
    else if (playerID == 4) RunAIScript("-Vi4");
    else if (playerID == 5) RunAIScript("-Vi5");
    else if (playerID == 6) RunAIScript("-Vi6");
    else if (playerID == 7) RunAIScript("-Vi7");
}

function GetLocationPoint(location) {
	const locTable = EPD(0x58DC4C);
	return dwread_epd(locTable + location * 5), dwread_epd(locTable + location * 5 + 1);
}

function CreateUnitDeathAtLocation(Unit, playerID, location) {
    CreateUnit(1, Unit, location, playerID);
    KillUnit(Unit, playerID);
}

function StoreSpawnPositions() {
    var monster_i = 0;
    var sigil_i = 0;
    foreach(unit : EUDLoopCUnit()) {
        if (unit.playerID == $P9) {
            if (unit.unitType == 215 && sigil_i < MAX_SIGIL_SPAWNS) {
                sigil_i++;
                sigil_x[sigil_i] = unit.posX;
                sigil_y[sigil_i] = unit.posY;
                unit.remove();
            } 
            else if (monster_i < MAX_MONSTER_SPAWNS) {
                monster_spawn_type[monster_i] = unit.unitType;
                monster_spawn_x[monster_i] = unit.posX;
                monster_spawn_y[monster_i] = unit.posY;
                unit.remove();
                monster_i++;
                if (monster_i > MAX_MONSTER_SPAWNS) {
                    DisplayTextAll("NOTICE: MAXIMUM SPAWN POSITIONS REACHED!");
                    break;
                }
            }

        }
    }
}

function GetSumOfActivePlayerBits() {
    var sum = 0;
    if (playerexist($P1)) sum += 1;
    if (playerexist($P2)) sum += 2;
    if (playerexist($P3)) sum += 4;
    if (playerexist($P4)) sum += 8;
    if (playerexist($P5)) sum += 16;
    if (playerexist($P6)) sum += 32;
    return sum;
}

function SpawnInitialItemUnits() {
    foreach(unit : EUDLoopCUnit()) {
        if (unit.playerID == $P10) {
            if (unit.unitType == U_MARKER) {
                const weapon_item_id = unit.hp / 256;
                setloc(L_MAIN, unit.posX, unit.posY);
                RemoveUnitAt(1, U_MARKER, L_MAIN, $P10);
                const new_unit = CUnit(CreateCUnit(U_WEAPON, $P8, L_MAIN));
                new_unit.energy = weapon_item_id;
                new_unit.shield = GetSumOfActivePlayerBits();
            }
        } else if (unit.playerID == $P11) {
            if (unit.unitType == U_MARKER) {
                const armor_id = unit.hp / 256;
                setloc(L_MAIN, unit.posX, unit.posY);
                RemoveUnitAt(1, U_MARKER, L_MAIN, $P11);
                const new_unit = CUnit(CreateCUnit(U_ARMOR, $P8, L_MAIN));
                new_unit.energy = armor_id;
                new_unit.shield = GetSumOfActivePlayerBits();
            }
        } else if (unit.playerID == $P12) {
            if (unit.unitType == U_MARKER) {
                const special_id = unit.hp / 256;
                var create_unit = 0;
                setloc(L_MAIN, unit.posX, unit.posY);
                RemoveUnitAt(1, U_MARKER, L_MAIN, $P12);
                if (special_id == 1) create_unit = U_LIFEPICKUP;
                const new_unit = CUnit(CreateCUnit(create_unit, $P8, L_MAIN));
                new_unit.shield = GetSumOfActivePlayerBits();
            }
        }
    }
}

function UnitItemHasBeenLooted(playerID, value) {
    if (value > 63) return 0;
    var check_bits = value;
    var p0, p1, p2, p3, p4, p5 = 0, 0, 0, 0, 0, 0;
    if (check_bits >= 32) {check_bits -= 32; p5 = 1;}
    if (check_bits >= 16) {check_bits -= 16; p4 = 1;}
    if (check_bits >= 8) {check_bits -= 8; p3 = 1;}
    if (check_bits >= 4) {check_bits -= 4; p2 = 1;}
    if (check_bits >= 2) {check_bits -= 2; p1 = 1;}
    if (check_bits >= 1) {check_bits -= 1; p0 = 1;}
    if (playerID == 0 && p0 > 0) return 0;
    else if (playerID == 1 && p1 > 0) return 0;
    else if (playerID == 2 && p2 > 0) return 0;
    else if (playerID == 3 && p3 > 0) return 0;
    else if (playerID == 4 && p4 > 0) return 0;
    else if (playerID == 5 && p5 > 0) return 0;
    return 1;
}

function ModifyItemLootedStatus(playerID, current_value) {
    if (current_value >= 1000) return 0; // return 0 if the item is non-shared
    var new_value = current_value;
    if (playerID == 0) new_value -= 1;
    else if (playerID == 1) new_value -= 2;
    else if (playerID == 2) new_value -= 4;
    else if (playerID == 3) new_value -= 8;
    else if (playerID == 4) new_value -= 16;
    else if (playerID == 5) new_value -= 32;
    return new_value; // if this returns 0 the item should be removed from the map
}

function GetChunkID(chunkX, chunkY) {
    // returns a value 1 -> 256, from coordinates 1 -> 256
    if (chunkX > 0 && chunkX <= 16 && chunkY > 0 && chunkY <= 16) {
        return (chunkY - 1) * 16 + chunkX;
    }
    return 0;
}

function GetChunkCoords(chunkID) {
    // returns coordinates 1 -> 256 from an id 1 -> 256
    var chunkx, chunky = 0, 0;
    if (chunkID > 16 && chunkID <= 256) {
        chunkx = ((chunkID - 1) % 16) + 1;
        chunky = ((chunkID - 1) / 16) + 1;
    } else if (chunkID > 0 && chunkID <= 16) {
        chunkx = chunkID;
        chunky = 1;
    }
    return chunkx, chunky;
}

function FillChunkBuffer(chunkX, chunkY) {
    // fills chunk buffer array with ids of the 8 surrounding chunks, ids are zero if not valid like at the edge of the map
    // starts top and goes clockwise.
    for (var i = 0; i < 8; i++) chunk_buffer[i] = 0;
    chunk_buffer[0] = GetChunkID(chunkX, chunkY - 1);
    chunk_buffer[1] = GetChunkID(chunkX + 1, chunkY - 1);
    chunk_buffer[2] = GetChunkID(chunkX + 1, chunkY);
    chunk_buffer[3] = GetChunkID(chunkX + 1, chunkY + 1);
    chunk_buffer[4] = GetChunkID(chunkX, chunkY + 1);
    chunk_buffer[5] = GetChunkID(chunkX - 1, chunkY + 1);
    chunk_buffer[6] = GetChunkID(chunkX - 1, chunkY);
    chunk_buffer[7] = GetChunkID(chunkX - 1, chunkY - 1);
}
// @bm SpawnUnitsAtChunk
function SpawnUnitsAtChunk(chunkX, chunkY) {
    const limit_left = ((chunkX - 1) * 16) * 32;
    const limit_right = limit_left + 512;
    const limit_top = ((chunkY - 1) * 16) * 32;
    const limit_bottom = limit_top + 512;
    for (var i = 0; i < 1000; i++) {
        if (monster_spawn_x[i] >= limit_left && monster_spawn_x[i] < limit_right && monster_spawn_y[i] >= limit_top && monster_spawn_y[i] < limit_bottom) {
            if (monster_spawn_type[i] > 0) {
                setloc(L_MAIN, monster_spawn_x[i], monster_spawn_y[i]);
                const new_unit = CreateCUnit(monster_spawn_type[i], $P7, L_MAIN);
                if (new_unit.unitID == U_GUARDIAN_ANGEL) {
                    MakeUnitNPC(new_unit, new_unit.unitID);
                    AttachWeaponToUnit(new_unit, WEAPON_ANCIENT_TOME_OF_STARFALL);
                }
                // if (new_unit.unitID == U_HILL_SPINT) {
                //     AttachWeaponToUnit(new_unit, WEAPON_SHORTBOW);
                // }
            }
        }
    }
    chunk_spawns[GetChunkID(chunkX, chunkY) - 1] += 1;
}

function JustEnteredChunk(chunkX, chunkY) {
    FillChunkBuffer(chunkX, chunkY);
    // screen.printfAt(8, "{} | {} | {}", chunk_buffer[7], chunk_buffer[0], chunk_buffer[1]);
    // screen.printfAt(9, "{} | -- | {}", chunk_buffer[6], chunk_buffer[2]);
    // screen.printfAt(10, "{} | {} | {}", chunk_buffer[5], chunk_buffer[4], chunk_buffer[3]);
    for (var i = 0; i < 8; i++) {
        if (chunk_buffer[i] > 0 && chunk_spawns[chunk_buffer[i] - 1] == 0) {
            const x, y = GetChunkCoords(chunk_buffer[i]);
            SpawnUnitsAtChunk(x, y);
        }
    }
    if (chunk_spawns[GetChunkID(chunkX, chunkY) - 1] == 0) SpawnUnitsAtChunk(chunkX, chunkY);
}

function GetChunkAtPos(positionx, positiony) {
    var chunk_pos_x = (positionx / 32) / 16;
    var chunk_pos_y = (positiony / 32) / 16;
    return chunk_pos_x + 1, chunk_pos_y + 1;
}

function IsPosWithinRect(positionx, positiony, left, right, top, bottom) {
    if (positionx >= left && positionx <= right && positiony >= top && positiony <= bottom) return 1;
    return 0;
}

function IsAlive(playerID) {
    if (Command(playerID, AtLeast, 1, U_HERO[playerID])) return 1;
    return 0;
}

function TeleportHeroPos(playerID, positionx, positiony) {
    setloc(L_MAIN, positionx, positiony);
    MoveUnit(1, U_HERO[playerID], playerID, L_ANYWHERE, L_MAIN);
    const unit = CUnit(p_cunit[playerID]);
    p_x[playerID], p_y[playerID] = unit.posX, unit.posY;
}

function PlayWavAtPos(sound_path_string: TrgString, positionx, positiony, max_distance) {
    for (var i = 0; i < 6; i++) {
        if (IsAlive(i) && GetDistance(p_x[i], p_y[i], positionx, positiony) <= max_distance) {
            const old_cp = getcurpl();
            setcurpl(i);
            PlayWAV(sound_path_string);
            setcurpl(old_cp);
        }
    }
}

function PlayWAVCP(sound_path_string: TrgString, playerID) {
    if (playerID > 7) return;
    const old_cp = getcurpl();
    setcurpl(playerID);
    PlayWAV(sound_path_string);
    setcurpl(old_cp);
}

function IsPosIndoors(positionx, positiony) {
    if (IsPosWithinRect(positionx, positiony, 3840, 4390, 1630, 2340)) return 1;
    if (IsPosWithinRect(positionx, positiony, 2870, 3580, 890, 1440)) return 1;
    if (IsPosWithinRect(positionx, positiony, 0, 1280, 1280, 2660)) return 1;
    if (IsPosWithinRect(positionx, positiony, 1281, 1890, 1470, 2150)) return 1;
    if (IsPosWithinRect(positionx, positiony, 1281, 1632, 2151, 2480)) return 1;
    if (IsPosWithinRect(positionx, positiony, 1632, 1696, 2270, 2370)) return 1;
    if (IsPosWithinRect(positionx, positiony, 3105, 3290, 3160, 3488)) return 1;
    return 0;
}

const AREA_GATE_MOUNTAIN = 1;
function GetAreaAtPos(positionx, positiony) {
    if (IsPosWithinRect(positionx, positiony, 540, 2970, 0, 896)) return AREA_GATE_MOUNTAIN;
    if (IsPosWithinRect(positionx, positiony, 1664, 1920, 897, 1024)) return AREA_GATE_MOUNTAIN;
    return 0;
}

function CreateImageSpriteAtLocation(playerID, location, imageID, drawFunc, iscript) {
    var new_iscript = iscript;
    if (new_iscript == 0) new_iscript = ISCRIPT_NORMAL;
    const prev_iscript = dwread(0x666778 + 34000 + imageID * 4);
    dwwrite(0x666778 + 34000 + imageID * 4, new_iscript); // change image iscript
    dwwrite(0x666778 + 14000 + imageID * 1, drawFunc); // change image drawfunc
	SetMemoryX(0x00666458, SetTo, imageID, 0x0000ffff); // change scanner image to input image
    CreateUnit(1, 33, location, playerID);
	RemoveUnit(33, playerID);
	SetMemoryX(0x00666458, SetTo, 546, 0x0000ffff); // revert scanner image
    dwwrite(0x666778 + 34000 + imageID * 4, prev_iscript); // revert image iscript
}

const included = EUDArray(6);
function RedeemUnitExp(playerID, unitType) {
    var amount_players_nearby = 0;
    var exp_to_gain = 0;
    if (unitType == U_CHIMERA) exp_to_gain += 30;
    else if (unitType == U_HILL_SPINT) exp_to_gain += 80;
    if (exp_to_gain == 0) return; // sometimes this function gets accessed without providing anything for unitType argument.
    for (var i = 0; i < 6; i++) {
        included[i] = 0;
        if (i != playerID && GetDistance(p_x[playerID], p_y[playerID], p_x[i], p_y[i]) <= 640) {
            amount_players_nearby += 1;
            included[i] = 1;
        }
    }
    if (amount_players_nearby > 0) {
        exp_to_gain = (exp_to_gain / (amount_players_nearby + 1)) + 1;
        for (var i = 0; i < 6; i++) {
            if (included[i] > 0) p_exp_buffer[i] += exp_to_gain;
        }
    }
    p_exp_buffer[playerID] += exp_to_gain;
}
// @bm DamageUnit
function DamageUnit(playerID, unit: CUnit, damage, index) {
    var target_state = 1;
    var damage_remaining = damage * 256;
    if (unit.shield > 0) {
        if (unit.shield < damage_remaining) {
            damage_remaining -= unit.shield;
            unit.shield = 0;
        } else {
            unit.shield -= damage_remaining;
            damage_remaining = 0;
        }
    }
    if (unit.hp <= damage_remaining) {
        unit.hp = 0;
    }
	if (unit.hp == 0) {
        if (unit.playerID == $P7 && index < ACTIVE_UNITS_MAX) active_units[index] = 0; // remove from active units array
        if (playerID >= 0 && playerID <= 5) RedeemUnitExp(playerID, unit.unitType);
        unit.die();
        target_state = 0;
    } else {
        unit.hp -= damage_remaining;
    }
    // AGGRO
    if (unit.playerID == $P7 && unit.orderID == 3 && playerID >= 0 && playerID <= 5) { // TODO refactor this later so its more direct using cunit instead of SCs action.
        setloc(L_MAIN, p_x[playerID], p_y[playerID]);
        unit.setloc(L_0x0);
        Order(unit.unitID, $P7, L_0x0, Attack, L_MAIN);
    }
    return target_state;
}

function HealPlayer(playerID, unit: CUnit, amount) {
    if (unit.hp == p_health_max[playerID]) return;
    else if (unit.hp + amount > p_health_max[playerID]) unit.hp = p_health_max[playerID];
    else unit.hp += amount;
}

function HealShieldPlayer(playerID, unit: CUnit, amount) {
    if (unit.shield == p_shield_max[playerID]) return;
    else if (unit.shield + amount > p_shield_max[playerID]) unit.shield = p_shield_max[playerID];
    else unit.shield += amount;
}

function DoMagicLifeDrainCost(playerID, unit: CUnit, amount) {
    if (playerID > 5) return;
    unit.hp -= amount;
    p_health_magic_drained[playerID] += amount;
}

function SCDirectionToDeg(direction) {
    var angle = direction * 14063;
    angle = (angle/10000) - 90; // could make this number readable in the future by keeping it in the range of 0 - 359
    return angle;
}

function GetAngle(originx, originy, destinationx, destinationy) {
    const angle = atan2(destinationy - originy, destinationx - originx);
    return angle;
}

function AddAngles(angle0, angle1) {
    var new_angle = angle0 + angle1;
    if (new_angle > 4000000000) new_angle += 360;
    else if (new_angle >= 360) new_angle -= 360;
    return new_angle;
}

function MovePosTowards(positionx, positiony, angle, distance) {
    const directionx, directiony = lengthdir(distance, angle);
    const new_positionx = positionx + directionx;
    const new_positiony = positiony + directiony;
    return new_positionx, new_positiony;
}

function Random(min, max) {
   return min + dwrand() / (4294967295 / (max - min + 1) + 1);
}

function PosIsOnMap(positionx, positiony) {
    if (positionx >= 0 && positionx <= 8191 && positiony >= 0 && positiony <= 8191) return 1;
    return 0;
}

function PosToSquare(positionx, positiony, width) {
    const half_width = width/2;
    var limit_left = 0;
    if (positionx > half_width) limit_left = positionx - half_width;
    const limit_right = positionx + half_width;
    var limit_top = 0;
    if (positiony > half_width) limit_top = positiony - half_width;
    const limit_bottom = positiony + half_width;
    return limit_left, limit_right, limit_top, limit_bottom;
}

function GetSpawnPosition(playerID) {
    if (playerID == 0) return 1984, 1184;
    else if (playerID == 1) return 2048, 1120;
    else if (playerID == 2) return 2128, 1072;
    else if (playerID == 3) return 2192, 1120;
    else if (playerID == 4) return 2144, 1168;
    else if (playerID == 5) return 2080, 1200;
    return 0, 0;
}

function SpawnHero(playerID) {
    if (debug_enabled) p_homepos_x[playerID], p_homepos_y[playerID] = GetLocationPoint(L_PLAYER[playerID]);
    if (p_homepos_x[playerID] == 0) p_homepos_x[playerID], p_homepos_y[playerID] = GetSpawnPosition(playerID);
    if (IsAlive(playerID)) RemoveUnit(U_HERO[playerID], playerID);
    setloc(L_MAIN, p_homepos_x[playerID], p_homepos_y[playerID]);
    p_cunit[playerID] = CreateCUnit(U_HERO[playerID], playerID, L_MAIN);
    CenterView(L_MAIN);
    const unit = CUnit(p_cunit[playerID]);
    unit.killCount = p_level_current[playerID];
}

function SetMaxHP(playerID, value) {
    p_health[playerID] = value;
    p_health_max[playerID] = value;
    dwwrite(0x65FD00 + 9808 + U_HERO[playerID] * 4, value);
    ModifyUnitHitPoints(1, U_HERO[playerID], playerID, L_ANYWHERE, 100);
}

function CalculateMaxShield(playerID) {
    p_shield_max[playerID] = 0;
    if (p_armor[playerID] == ARMOR_SHATTERED_KNIGHTS) p_shield_max[playerID] += 100 * 256;
}

function EquipItem(item_id, unitType, playerID) {
    if (unitType == U_WEAPON) {
        weapon_id[playerID] = item_id;
    } else if (unitType == U_UTILITY) {
        utility_id[playerID] = item_id;
    } else if (unitType == U_ARMOR) {
        p_armor[playerID] = item_id;
        CalculateMaxShield(playerID);
    }
}

function SetHeroDefaults(playerID) {
    p_level_current[playerID] = 1;
    p_exp_goal[playerID] = 150;
    p_shield_max[playerID] = PLAYER_DEFAULT_SHIELD * 256;
    p_damage[playerID] = PLAYER_DEFAULT_DAMAGE;
    p_attributepoints[playerID] = PLAYER_DEFAULT_ATTRIBUTE;
    SetMaxHP(playerID, PLAYER_DEFAULT_HP * 256);
}

function DrawCircle(positionx, positiony, diameter, dots, imageID, drawFunc, iscript) {
    var angle_increment = (3600000 / dots) / 10000;
    var angle = 0;
    for (var i = 0; i < dots; i++) {
        const x, y = MovePosTowards(positionx, positiony, angle, diameter / 2);
        setloc(L_MAIN, x, y);
        CreateImageSpriteAtLocation($P8, L_MAIN, imageID, drawFunc, iscript);
        angle += angle_increment;
    }
}

function DrawLine(originx, originy, destinationx, destinationy, dots, imageID, drawFunc, iscript) {
    const d = GetDistance(originx, originy, destinationx, destinationy);
    const a = GetAngle(originx, originy, destinationx, destinationy);
    const increment = ((d * 10000) / dots) / 10000;
    for (var i = 0; i < dots; i++) {
        const x, y = MovePosTowards(originx, originy, a, increment * i);
        setloc(L_MAIN, x, y);
        CreateImageSpriteAtLocation($P8, L_MAIN, imageID, drawFunc, iscript);
    }
}

function DrawRect(positionx, positiony, width, height, dots, imageID, drawFunc, iscript) {
    const half_width = width / 2;
    const half_height = height / 2;
    DrawLine(positionx - half_width, positiony - half_height, positionx + half_width, positiony - half_height, dots / 4, imageID, drawFunc, iscript);
    DrawLine(positionx + half_width, positiony - half_height, positionx + half_width, positiony + half_height, dots / 4, imageID, drawFunc, iscript);
    DrawLine(positionx + half_width, positiony + half_height, positionx - half_width, positiony + half_height, dots / 4, imageID, drawFunc, iscript);
    DrawLine(positionx - half_width, positiony + half_height, positionx - half_width, positiony - half_height, dots / 4, imageID, drawFunc, iscript);
}

function ClearTextLines(from_line, to_line) {
    for (var i = from_line; i < to_line + 1; i++) {
        DisplayTextAt(i, "\x0BNull");
    }
}

const hud_value = PVariable();
const hud_value_string = PVariable();
const hud_value_timer = PVariable();
function SetHudValue(playerID, value, string_var) {
    hud_value[playerID] = value;
    hud_value_string[playerID] = string_var;
    hud_value_timer[playerID] = 72;
}

function GetHeight(positionx, positiony) {
    if (!PosIsOnMap(positionx, positiony)) return 0;
    var height = 0;
    setloc(L_MAIN, positionx, positiony);
    MoveUnit(All, U_CHECKHEIGHT, $P12, L_ANYWHERE, L_MAIN);
    MoveLocation(L_HEIGHT0, U_CHECKHEIGHT, $P12, L_ANYWHERE);
    MoveLocation(L_HEIGHT1, U_CHECKHEIGHT, $P12, L_ANYWHERE);
    MoveLocation(L_HEIGHT2, U_CHECKHEIGHT, $P12, L_ANYWHERE);
    if (Bring($P12, AtLeast, 1, U_CHECKHEIGHT, L_HEIGHT0) ) height = 1;
    else if (Bring($P12, AtLeast, 1, U_CHECKHEIGHT, L_HEIGHT1) ) height = 2;
    else if (Bring($P12, AtLeast, 1, U_CHECKHEIGHT, L_HEIGHT2) ) height = 3;
    MoveUnit(All, U_CHECKHEIGHT, $P12, L_ANYWHERE, L_CHECK);
    return height;
}

function PosIsPathable(positionx, positiony, distance_tolerance) {
    const unit = CUnit(cunit_pathable);
    setloc(L_MAIN, positionx, positiony);
    MoveUnit(All, U_PATHABLE, $P12, L_ANYWHERE, L_MAIN);
    if (GetDistance(unit.posX, unit.posY, positionx, positiony) <= distance_tolerance) {
        MoveUnit(All, U_PATHABLE, $P12, L_ANYWHERE, L_CHECK);
        return 1;
    }
    MoveUnit(All, U_PATHABLE, $P12, L_ANYWHERE, L_CHECK);
    return 0;
}

var col_posx = 0;
var col_posy = 0;
var col_enemies = 0;
var col_allies = 0;
var col_terrain = 0; // check if the posx, posy is unpathable.
var col_shape = 0; // determines if the check will be for circle or square. Shape only works for units. 
var col_shape_size = 0; // width of the square, or diameter of the circle.
var col_max_results = 0; // should probably increase max results in the future and make it a constant
const col_results_unit = EUDArray(8); // unit pointers
const col_results_unit_activei = EUDArray(8); // index position of the unit in the active units array, this is for deleting it from the active units array if it dies.
var col_results_unit_i = 0; // keeps track of how many things have been added to the results array
var col_results_terrain = 0;
function AddUnitToColResults(value, indexfromactive) {
    if (col_results_unit_i < col_max_results) {
        col_results_unit[col_results_unit_i] = value;
        col_results_unit_activei[col_results_unit_i] = indexfromactive;
        col_results_unit_i++;
        return 0;
    } else {
        return 1;
    } // returns 0 if results are not full, returns 1 if results are full
}

function ResetCheckCollision() {
    col_posx = 0;
    col_posy = 0;
    col_enemies = 0;
    col_allies = 0;
    col_terrain = 0;
    col_shape = 0;
    col_shape_size = 0;
    col_max_results = 0;
    for (var i = 0; i < 8; i++) col_results_unit[i] = 0;
    for (var i = 0; i < 8; i++) col_results_unit_activei[i] = 0;
    col_results_unit_i = 0;
    col_results_terrain = 0;
}
// @bm CheckCollision
function CheckCollision(playerID) {
    // checks for things according to the configuration of the above vars. use results vars for the results of the check.
    // need to make this check for alliance status
    var result_exists = 0;
    var check_from = 0;
    var check_to = 0;
    if (playerID < 6) {
        check_from = playerID * ACTIVE_UNITS_MAX;
        check_to = check_from + ACTIVE_UNITS_MAX;
    } else {
        check_to = ACTIVE_UNITS_MAX * 6;
    }
    if (col_allies || col_enemies) {
        if (col_shape == 0) {
            const l, r, t, b = PosToSquare(col_posx, col_posy, col_shape_size);
            for (var u = check_from; u < check_to; u++) {
                if (active_units[u] > 0) {
                    const unit = CUnit(active_units[u]);
                    if (col_enemies == 0 && !isAlly(playerID, unit.playerID)) continue;
                    if (col_allies == 0 && isAlly(playerID, unit.playerID)) continue;
                    if (unit.hp > 0 && IsPosWithinRect(unit.posX, unit.posY, l, r, t, b)) {
                        result_exists = 1;
                        const full = AddUnitToColResults(active_units[u], u);
                        if (full) break;
                    }
                }
            }
        } else if (col_shape == 1) {
            for (var u = check_from; u < check_to; u++) {
                if (active_units[u] > 0) {
                    const unit = CUnit(active_units[u]);
                    if (unit.hp > 0 && GetDistance(unit.posX, unit.posY, col_posx, col_posy) <= col_shape_size) {
                        result_exists = 1;
                        const full = AddUnitToColResults(active_units[u], u);
                        if (full) break;
                    }
                }
            }
        }
    }
    if (col_terrain) {
        if (!PosIsPathable(col_posx, col_posy, col_shape_size)) col_results_terrain = 1;
        else col_results_terrain = 0;
    }
    return result_exists;
}

// @bm PROJECTILE FUNCTIONS
const PROJECTILE_POOL = 192;
const pro_owner = EUDArray(PROJECTILE_POOL);
const pro_posx = EUDArray(PROJECTILE_POOL);
const pro_posy = EUDArray(PROJECTILE_POOL);
const pro_time = EUDArray(PROJECTILE_POOL);
const pro_maxtime = EUDArray(PROJECTILE_POOL);
const pro_angle = EUDArray(PROJECTILE_POOL);
const pro_velocity = EUDArray(PROJECTILE_POOL);
const pro_angular_velocity = EUDArray(PROJECTILE_POOL);
const pro_orbit = EUDArray(PROJECTILE_POOL);
const pro_orbit_velocity = EUDArray(PROJECTILE_POOL);
const pro_orbit_dist = EUDArray(PROJECTILE_POOL);
const pro_effect0_type = EUDArray(PROJECTILE_POOL); //whether the effect is an image or a unit death
const pro_effect0 = EUDArray(PROJECTILE_POOL);
const pro_effect0_start = EUDArray(PROJECTILE_POOL);
const pro_effect0_drawfunc = EUDArray(PROJECTILE_POOL);
const pro_effect0_iscript = EUDArray(PROJECTILE_POOL);
const pro_effect1_type = EUDArray(PROJECTILE_POOL);
const pro_effect1 = EUDArray(PROJECTILE_POOL);
const pro_effect1_start = EUDArray(PROJECTILE_POOL);
const pro_effect1_drawfunc = EUDArray(PROJECTILE_POOL);
const pro_effect1_iscript = EUDArray(PROJECTILE_POOL);
const pro_effect2_type = EUDArray(PROJECTILE_POOL);
const pro_effect2 = EUDArray(PROJECTILE_POOL);
const pro_effect2_start = EUDArray(PROJECTILE_POOL);
const pro_effect2_drawfunc = EUDArray(PROJECTILE_POOL);
const pro_effect2_iscript = EUDArray(PROJECTILE_POOL);
const pro_weapon_id = EUDArray(PROJECTILE_POOL);
const pro_collide_enemies = EUDArray(PROJECTILE_POOL);
const pro_collide_allies = EUDArray(PROJECTILE_POOL);
const pro_collide_terrain = EUDArray(PROJECTILE_POOL);
const pro_collide_shape = EUDArray(PROJECTILE_POOL);
const pro_collide_size = EUDArray(PROJECTILE_POOL);
const pro_collision_pos_x = EUDArray(PROJECTILE_POOL); // these are results that exist after the projectile has collided with something
const pro_collision_pos_y = EUDArray(PROJECTILE_POOL);
const pro_collision_unit = EUDArray(PROJECTILE_POOL);
function ResetProjectile(i) {
    pro_owner[i] = 0;
    pro_time[i] = 0;
    pro_maxtime[i] = 0;
    pro_posx[i] = 0;
    pro_posy[i] = 0;
    pro_angle[i] = 0;
    pro_velocity[i] = 0;
    pro_angular_velocity[i] = 0;
    pro_orbit[i] = 0;
    pro_orbit_velocity[i] = 0;
    pro_orbit_dist[i] = 0;
    pro_effect0_type[i] = 0;
    pro_effect0[i] = 0;
    pro_effect0_start[i] = 0;
    pro_effect0_drawfunc[i] = 0;
    pro_effect0_iscript[i] = 0;
    pro_effect1_type[i] = 0;
    pro_effect1[i] = 0;
    pro_effect1_start[i] = 0;
    pro_effect1_drawfunc[i] = 0;
    pro_effect1_iscript[i] = 0;
    pro_effect2_type[i] = 0;
    pro_effect2[i] = 0;
    pro_effect2_start[i] = 0;
    pro_effect2_drawfunc[i] = 0;
    pro_effect2_iscript[i] = 0;
    pro_weapon_id[i] = 0;
    pro_collide_enemies[i] = 0;
    pro_collide_allies[i] = 0;
    pro_collide_terrain[i] = 0;
    pro_collide_shape[i] = 0;
    pro_collide_size[i] = 0;
    pro_collision_pos_x[i] = 0;
    pro_collision_pos_y[i] = 0;
    pro_collision_unit[i] = 0;
}

var queue_pro_owner = 0;
var queue_pro_posx = 0;
var queue_pro_posy = 0;
var queue_pro_time = 0;
var queue_pro_maxtime = 0;
var queue_pro_angle = 0;
var queue_pro_velocity = 0;
var queue_pro_angular_velocity = 0;
var queue_pro_orbit = 0;
var queue_pro_orbit_velocity = 0;
var queue_pro_orbit_dist = 0;
var queue_pro_effect0_type = 0;
var queue_pro_effect0 = 0;
var queue_pro_effect0_start = 0;
var queue_pro_effect0_drawfunc = 0;
var queue_pro_effect0_iscript = 0;
var queue_pro_effect1_type = 0;
var queue_pro_effect1 = 0;
var queue_pro_effect1_start = 0;
var queue_pro_effect1_drawfunc = 0;
var queue_pro_effect1_iscript = 0;
var queue_pro_effect2_type = 0;
var queue_pro_effect2 = 0;
var queue_pro_effect2_start = 0;
var queue_pro_effect2_drawfunc = 0;
var queue_pro_effect2_iscript = 0;
var queue_pro_weapon_id = 0;
var queue_pro_collide_enemies = 0;
var queue_pro_collide_allies = 0;
var queue_pro_collide_terrain = 0;
var queue_pro_collide_shape = 0;
var queue_pro_collide_size = 0;
function ResetProjectileQueue() {
    queue_pro_owner = 0;
    queue_pro_posx = 0;
    queue_pro_posy = 0;
    queue_pro_time = 0;
    queue_pro_maxtime = 0;
    queue_pro_angle = 0;
    queue_pro_velocity = 0;
    queue_pro_angular_velocity = 0;
    queue_pro_orbit = 0;
    queue_pro_orbit_velocity = 0;
    queue_pro_orbit_dist = 0;
    queue_pro_effect0_type = 0;
    queue_pro_effect0 = 0;
    queue_pro_effect0_start = 0;
    queue_pro_effect0_drawfunc = 0;
    queue_pro_effect0_iscript = 0;
    queue_pro_effect1_type = 0;
    queue_pro_effect1 = 0;
    queue_pro_effect1_start = 0;
    queue_pro_effect1_drawfunc = 0;
    queue_pro_effect1_iscript = 0;
    queue_pro_effect2_type = 0;
    queue_pro_effect2 = 0;
    queue_pro_effect2_start = 0;
    queue_pro_effect2_drawfunc = 0;
    queue_pro_effect2_iscript = 0;
    queue_pro_weapon_id = 0;
    queue_pro_collide_enemies = 0;
    queue_pro_collide_allies = 0;
    queue_pro_collide_terrain = 0;
    queue_pro_collide_shape = 0;
    queue_pro_collide_size = 0;
}

function CreateProjectile() {
    for (var i = 0; i < PROJECTILE_POOL; i++) {
        if (pro_time[i] == 0) {
            pro_owner[i] = queue_pro_owner;
            pro_time[i] = 1;
            pro_maxtime[i] = queue_pro_maxtime;
            pro_posx[i] = queue_pro_posx;
            pro_posy[i] = queue_pro_posy;
            pro_angle[i] = queue_pro_angle;
            pro_velocity[i] = queue_pro_velocity;
            pro_angular_velocity[i] = queue_pro_angular_velocity;
            pro_orbit[i] = queue_pro_angle;
            pro_orbit_velocity[i] = queue_pro_orbit_velocity;
            pro_orbit_dist[i] = queue_pro_orbit_dist;
            pro_effect0_type[i] = queue_pro_effect0_type;
            pro_effect0[i] = queue_pro_effect0;
            pro_effect0_start[i] = queue_pro_effect0_start;
            pro_effect0_drawfunc[i] = queue_pro_effect0_drawfunc;
            pro_effect0_iscript[i] = queue_pro_effect0_iscript;
            pro_effect1_type[i] = queue_pro_effect1_type;
            pro_effect1[i] = queue_pro_effect1;
            pro_effect1_start[i] = queue_pro_effect1_start;
            pro_effect1_drawfunc[i] = queue_pro_effect1_drawfunc;
            pro_effect1_iscript[i] = queue_pro_effect1_iscript;
            pro_effect2_type[i] = queue_pro_effect2_type;
            pro_effect2[i] = queue_pro_effect2;
            pro_effect2_start[i] = queue_pro_effect2_start;
            pro_effect2_drawfunc[i] = queue_pro_effect2_drawfunc;
            pro_effect2_iscript[i] = queue_pro_effect2_iscript;
            pro_weapon_id[i] = queue_pro_weapon_id;
            pro_collide_enemies[i] = queue_pro_collide_enemies;
            pro_collide_allies[i] = queue_pro_collide_allies;
            pro_collide_terrain[i] = queue_pro_collide_terrain;
            pro_collide_shape[i] = queue_pro_collide_shape;
            pro_collide_size[i] = queue_pro_collide_size;
            ResetProjectileQueue();
            break;
        }
    }
}
// @bm UpdateProjectiles
function UpdateProjectiles() {
    for (var i = 0; i < PROJECTILE_POOL; i++) {
        if (pro_time[i] > 0) {
            pro_time[i] += 1;
            pro_angle[i] = AddAngles(pro_angle[i], pro_angular_velocity[i]);
            const new_posx, new_posy = MovePosTowards(pro_posx[i], pro_posy[i], pro_angle[i], pro_velocity[i]);
            pro_posx[i] = new_posx;
            pro_posy[i] = new_posy;

            // CHECK COLLISION
            col_posx = pro_posx[i];
            col_posy = pro_posy[i];
            col_enemies = pro_collide_enemies[i];
            col_allies = pro_collide_allies[i];
            col_terrain = pro_collide_terrain[i];
            col_shape = pro_collide_shape[i];
            col_shape_size = pro_collide_size[i];
            col_max_results = 1;
            const had_collision = CheckCollision(pro_owner[i]);
            if (had_collision) {
                pro_collision_pos_x[i], pro_collision_pos_y[i] = pro_posx[i], pro_posy[i];
                pro_collision_unit[i] = col_results_unit[0];
            }
            ResetCheckCollision();

            pro_orbit[i] = AddAngles(pro_orbit[i], pro_orbit_velocity[i]);
            const offsetx, offsety = MovePosTowards(new_posx, new_posy, pro_orbit[i], pro_orbit_dist[i]);
            setloc(L_MAIN, offsetx, offsety);
            // IMAGES
            if (PosIsOnMap(offsetx, offsety) ) {
                if (pro_effect0[i] > 0 && pro_time[i] >= pro_effect0_start[i] && pro_time[i] < pro_effect1_start[i]) {
                    // time for effect 0
                    if (pro_effect0_type[i] == 0) CreateImageSpriteAtLocation($P8, L_MAIN, pro_effect0[i], pro_effect0_drawfunc[i], pro_effect0_iscript[i]);
                    else CreateUnitDeathAtLocation(pro_effect0[i], $P8, L_MAIN);
                } else if (pro_effect1[i] > 0 && pro_time[i] >= pro_effect1_start[i] && pro_time[i] < pro_effect2_start[i]) {
                    // time for effect 1
                    if (pro_effect1_type[i] == 0) CreateImageSpriteAtLocation($P8, L_MAIN, pro_effect1[i], pro_effect1_drawfunc[i], pro_effect1_iscript[i]);
                    else CreateUnitDeathAtLocation(pro_effect1[i], $P8, L_MAIN);
                } else if (pro_effect2[i] > 0 && pro_time[i] >= pro_effect2_start[i]) {
                    // time for effect 2
                    if (pro_effect2_type[i] == 0) CreateImageSpriteAtLocation($P8, L_MAIN, pro_effect2[i], pro_effect2_drawfunc[i], pro_effect2_iscript[i]);
                    else CreateUnitDeathAtLocation(pro_effect2[i], $P8, L_MAIN);
                }
            }
            if (pro_time[i] >= pro_maxtime[i]) {
                ResetProjectile(i);
            }
        }
    }
}

function UpdateProjectileCollisions() {
    for (var i = 0; i < PROJECTILE_POOL; i++) {
        if (pro_collision_pos_x[i] > 0) {
            // SHORT BOW
            if (pro_weapon_id[i] == WEAPON_SHORTBOW) {
                const damage = GetWeaponDamage(WEAPON_SHORTBOW, 0, pro_owner[i]);
                const target_state = DamageUnit(pro_owner[i], pro_collision_unit[i], damage, ACTIVE_UNITS_MAX + 1);
                setloc(L_MAIN, pro_collision_pos_x[i], pro_collision_pos_y[i]);
                if (pro_owner[i] < 6) SetHudValue(pro_owner[i], damage, STRING_WEAPON_DAMAGE);
                if (target_state) {
                    CreateUnitDeathAtLocation(U_SCOURGE, $P8, L_MAIN);
                    PlayWAVCP("staredit/wav/hitmarker.ogg", pro_owner[i]);
                } else if (target_state == 0) {
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_ZERG_AIR_DEATH_SMALL, 0, ISCRIPT_NORMAL);
                    PlayWAVCP("staredit/wav/hitmarker.ogg", pro_owner[i]);
                }
            }
            // LIGHTNING BLAST
            if (pro_weapon_id[i] == WEAPON_LIGHTNINGBLAST) {
                const damage = GetWeaponDamage(WEAPON_LIGHTNINGBLAST, 1, pro_owner[i]);
                const target_state = DamageUnit(pro_owner[i], pro_collision_unit[i], damage, ACTIVE_UNITS_MAX + 1);
                setloc(L_MAIN, pro_collision_pos_x[i], pro_collision_pos_y[i]);
                if (pro_owner[i] < 6) SetHudValue(pro_owner[i], damage, STRING_WEAPON_DAMAGE);
                if (target_state) {
                    CreateUnitDeathAtLocation(U_SCOURGE, $P8, L_MAIN);
                    PlayWAVCP("staredit/wav/hitmarker.ogg", pro_owner[i]);
                } else if (target_state == 0) {
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_ZERG_AIR_DEATH_SMALL, 0, ISCRIPT_NORMAL);
                    PlayWAVCP("staredit/wav/hitmarker.ogg", pro_owner[i]);
                }
            }
            ResetProjectile(i); // can decide if projectile continues after a collision by changing this
        }
    }
}

const EVENT_POOL = 192;
const event_posx = EUDArray(EVENT_POOL);
const event_posy = EUDArray(EVENT_POOL);
const event_time = EUDArray(EVENT_POOL);
const event_maxtime = EUDArray(EVENT_POOL);
const event_size = EUDArray(EVENT_POOL);
const event_shape = EUDArray(EVENT_POOL);
const event_heal = EUDArray(EVENT_POOL);
const event_damage = EUDArray(EVENT_POOL);
const event_owner = EUDArray(EVENT_POOL);
const event_maxtargets = EUDArray(EVENT_POOL);
const event_affect_enemies = EUDArray(EVENT_POOL);
const event_affect_allies = EUDArray(EVENT_POOL);
function ResetEvent(i) {
    event_posx[i] = 0;
    event_posy[i] = 0;
    event_time[i] = 0;
    event_maxtime[i] = 0;
    event_size[i] = 0;
    event_shape[i] = 0;
    event_heal[i] = 0;
    event_damage[i] = 0;
    event_owner[i] = 0;
    event_maxtargets[i] = 0;
    event_affect_enemies[i] = 0;
    event_affect_allies[i] = 0;
}

var queue_event_posx = 0;
var queue_event_posy = 0;
var queue_event_time = 0;
var queue_event_maxtime = 0;
var queue_event_size = 0;
var queue_event_shape = 0;
var queue_event_heal = 0;
var queue_event_damage = 0;
var queue_event_owner = 0;
var queue_event_maxtargets = 0;
var queue_event_affect_enemies = 0;
var queue_event_affect_allies = 0;
function ResetEventQueue() {
    queue_event_posx = 0;
    queue_event_posy = 0;
    queue_event_time = 0;
    queue_event_maxtime = 0;
    queue_event_size = 0;
    queue_event_shape = 0;
    queue_event_heal = 0;
    queue_event_damage = 0;
    queue_event_owner = 0;
    queue_event_maxtargets = 0;
    queue_event_affect_enemies = 0;
    queue_event_affect_allies = 0;
}

function CreateEvent() {
    for (var i = 0; i < EVENT_POOL; i++) {
        if (event_time[i] == 0) {
            event_time[i] = 1;
            event_posx[i] = queue_event_posx;
            event_posy[i] = queue_event_posy;
            event_maxtime[i] = queue_event_maxtime;
            event_size[i] = queue_event_size;
            event_shape[i] = queue_event_shape;
            event_heal[i] = queue_event_heal;
            event_damage[i] = queue_event_damage;
            event_owner[i] = queue_event_owner;
            event_maxtargets[i] = queue_event_maxtargets;
            event_affect_enemies[i] = queue_event_affect_enemies;
            event_affect_allies[i] = queue_event_affect_allies;
            ResetEventQueue();
            break;
        }
    }
}

function UpdateEvents() {
    for (var i = 0; i < EVENT_POOL; i++) {
        if (event_time[i] > 0) {
            const playerID = event_owner[i];
            col_posx = event_posx[i];
            col_posy = event_posy[i];
            col_shape_size = event_size[i];
            col_max_results = event_maxtargets[i]; 
            col_enemies = event_affect_enemies[i];
            col_allies = event_affect_allies[i];
            const result_exists = CheckCollision(playerID);
            if (result_exists) {
                for (var result_i = 0; result_i < col_max_results; result_i++) {
                    if (col_results_unit[result_i] > 0) {
                        const target = CUnit(col_results_unit[result_i]);
                        if (event_damage[i] > 0) DamageUnit(playerID, target, event_damage[i], col_results_unit_activei[result_i]);
                    }
                }
            }
            ResetCheckCollision();
            event_time[i]++;
            if (event_time[i] >= event_maxtime[i]) {
                ResetEvent(i);
            }
        }
    }
}

function UpdateTime() {
    time_state_changed = 0;
    time += 1;
    total_time += 1;
    if (time > FULL_DAY_LENGTH) {
        time = 0; 
        time_state = 0;
        time_state_changed = 1;
        days_elapsed += 1;
        DisplayTextAll("\x13\x03--+ The Sun Rises +--");
    } else if (time_state == 0 && time >= FULL_DAY_LENGTH/2) {
        time_state = 1;
        time_state_changed = 1;
        DisplayTextAll("\x13\x1C--+ The Sun Sets +--");
    }
}

function DoDamageAtPos(positionx, positiony, playerID, shape, size, damage, maxtargets) {
    queue_event_owner = playerID;
    queue_event_posx = positionx;
    queue_event_posy = positiony;
    queue_event_shape = shape;
    queue_event_size = size;
    queue_event_damage = damage;
    queue_event_affect_enemies = 1;
    queue_event_maxtargets = maxtargets;
    queue_event_maxtime = 1;
    CreateEvent();
}

var fow_state;
function UpdateFOW() {
    if (fow_state == 0) {
        fow_state = 1;
        SetMemory(0x0051CE98, SetTo, 0);
    } else {
        fow_state = 0;
        SetMemory(0x0051CE98, SetTo, 1);
    }
}

function UpdateSigils() {
    for (var i = 0; i < MAX_SIGIL_SPAWNS; i++) {
        if (sigil_x[i] > 0) {
            var player_on_sigil = 0;
            for (var p = 0; p < 6; p++) {
                if (p_current_sigil[p] == i && p_on_sigil[p] > 0) {
                    player_on_sigil = 1;
                    break;
                }
            }
            if (player_on_sigil) {
                sigil_glow[i]++;
                if (sigil_glow[i] >= 24) {
                    DrawCircle(sigil_x[i], sigil_y[i], SIGIL_DIAMETER, 24, 443, 0, ISCRIPT_NORMAL);
                    sigil_glow[i] = 0;
                }
            } else sigil_glow[i] = 0;
        }
    }
}

function UpdateBrightness(playerID) {
    var target_brightness = BRIGHTNESS_DEFAULT;
    if (time_state == 1) target_brightness = BRIGHTNESS_NIGHT;
    if (p_indoors[playerID]) target_brightness -= 6;
    if (p_brightness[playerID] < target_brightness) p_brightness[playerID] += 1;
    else if (p_brightness[playerID] > target_brightness) p_brightness[playerID] -= 1;
    if (IsUserCP()) SetMemoryEPD(EPD(0x657A9C), SetTo, p_brightness[playerID]);
}

function UpdateSightRange(playerID) {
    var target_value = PLAYER_DEFAULT_SIGHT;
    if (time_state == 1) target_value = PLAYER_DEFAULT_SIGHT - 4;
    if (p_indoors[playerID] && time_state == 0) target_value = 2;
    else if (p_indoors[playerID]) target_value = 1;
    bwrite(0x65FD00 + 13624 + U_HERO[playerID] * 1, target_value);
}

function UpdateSigilMenu(playerID) {
    if (keypress_1[playerID] && p_attributepoints[playerID] > 0) {
        p_strength[playerID]++;
        p_attributepoints[playerID]--;
        CalculateKnightSwordDamage(playerID);
        for (var i = 0; i < 8; i++) {
            queue_pro_posx = p_x[playerID];
            queue_pro_posy = p_y[playerID];
            queue_pro_maxtime = 5;
            queue_pro_angle = (i + 1) * 45;
            queue_pro_velocity = 20;
            queue_pro_effect2 = 450;
            queue_pro_effect2_start = 3;
            CreateProjectile();
        }
        PlayWAV("staredit/wav/increase_attribute.ogg");
        PlayWAV("sound/Bullet/ZLrkHit2.wav");
    }
    if (keypress_2[playerID] && p_attributepoints[playerID] > 0) {
        p_dexterity[playerID]++;
        p_attributepoints[playerID]--;
        for (var i = 0; i < 8; i++) {
            queue_pro_posx = p_x[playerID];
            queue_pro_posy = p_y[playerID];
            queue_pro_maxtime = 5;
            queue_pro_angle = (i + 1) * 45;
            queue_pro_velocity = 20;
            queue_pro_effect2 = 505;
            queue_pro_effect2_start = 3;
            CreateProjectile();
        }
        PlayWAV("staredit/wav/increase_attribute.ogg");
        PlayWAV("sound/Bullet/ZLrkHit2.wav");
    }
    if (keypress_3[playerID] && p_attributepoints[playerID] > 0) {
        p_resilience[playerID]++;
        p_attributepoints[playerID]--;
        for (var i = 0; i < 8; i++) {
            queue_pro_posx = p_x[playerID];
            queue_pro_posy = p_y[playerID];
            queue_pro_maxtime = 5;
            queue_pro_angle = (i + 1) * 45;
            queue_pro_velocity = 20;
            queue_pro_effect2 = 466;
            queue_pro_effect2_start = 3;
            CreateProjectile();
        }
        PlayWAV("staredit/wav/increase_attribute.ogg");
        PlayWAV("sound/Bullet/ZLrkHit2.wav");
    }
    screen.printfAt(0, "\x09\x09\x09\x11.STRENGTH \x1F({})\x09\x09\x09\x09\x07.DEXTERITY \x1F({})\x09\x09\x09\x09\x1C.RESILIENCE \x1F({})", p_strength[playerID], p_dexterity[playerID], p_resilience[playerID]);
    DisplayTextAt(1, "\x09\x09\x09\x03.Press -<1>- to Allocate\x09\x09\x03.Press -<2>- to Allocate\x09\x09\x03.Press -<3>- to Allocate");
    DisplayTextAt(2, "\x09\x09\x09\x11|\x04Sword Effectiveness\x09\x09\x07|\x04Bow Effectiveness\x09\x09\x09\x1C|\x04Magic Effectiveness");
    DisplayTextAt(3, "\x09\x09\x09\x11|\x04Life Regeneration\x09\x09\x09\x07|\x04Life Toughness\x09\x09\x09\x09\x1C|\x04Armor Toughness");
    DisplayTextAt(4, "\x09\x09\x09\x11|\x04Something\x09\x09\x09\x09\x09\x07|\x04Attack Speed\x09\x09\x09\x09\x1C|\x04Life Drain Recovery");
    DisplayTextAt(5, "\x0BNull");
    screen.printfAt(6, "\x09\x09\x09\x04Available Attribute Points: \x1F{}", p_attributepoints[playerID]);
}

function ResetWeaponIndex(index) {
    weapon_cunit[index] = 0;
    weapon_id[index] = 0;
    weapon_state[index] = 0;
    weapon_cooldown[index] = 0;
    weapon_angle[index] = 0;
    weapon_x[index] = 0;
    weapon_y[index] = 0;
}
// @bm UpdateWeaponState
function UpdateWeaponState(playerID) {
    var check_from = 0;
    var check_to = 0;
    if (playerID >= 0 && playerID <= 5) {
        check_from = playerID;
        check_to = playerID + 1;
    } else if (playerID == $P7) {
        check_from = 6;
        check_to = MAX_WEAPON_OBJECTS;
    }
    for (var weapon_index = check_from; weapon_index < check_to; weapon_index++) {
        const i = weapon_index;
        if (weapon_id[i] > 0) {
            var unit_ptr = weapon_cunit[i]; // set unit to whatever the weapon id is attached to
            var is_player = 0;
            var unit_just_attacked = 0;
            var unit_x = 0;
            var unit_y = 0;
            var unit_order_x = 0;
            var unit_order_y = 0;
            var unit_angle = 0;
            var display_damage = 0;
            if (i >= 0 && i <= 5) {unit_ptr = p_cunit[i]; is_player = 1;} // set unit to players unit if its a player
            const unit = CUnit(unit_ptr);
            if (is_player) {
                unit_just_attacked = p_just_attacked[i];
                unit_x = p_x[i];
                unit_y = p_y[i];
                unit_order_x = p_orderx[i];
                unit_order_y = p_ordery[i];
                unit_angle = p_angle[i];
            } else if (playerID == $P7) {
                if (unit.hp == 0) {
                    ResetWeaponIndex(i);
                    continue;
                }
                unit_x = unit.posX;
                unit_y = unit.posY;
                unit_order_x = unit.orderTargetX;
                unit_order_y = unit.orderTargetY;
                unit_angle = SCDirectionToDeg(unit.currentDirection1);
            }

            // TRIGGER
            if (weapon_cooldown[i] > 0) weapon_cooldown[i]--;
            var weapon_triggered = CheckForWeaponTrigger(playerID, unit, weapon_id[i]);
            if (weapon_triggered && weapon_cooldown[i] == 0) {
                weapon_cooldown[i] = GetWeaponCooldown(weapon_id[i]);
                weapon_state[i] = 1;
            }

            // SHORT SWORD
            if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_SHORTSWORD) {
                if (weapon_state[i] == 1) {
                    const damage = GetWeaponDamage(weapon_id[i], weapon_state[i], playerID);
                    weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, unit_angle, 32);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 128, damage, 2);
                    weapon_angle[i] = unit_angle + 60;
                    PlaySword();
                    display_damage = damage;
                }
                if (weapon_state[i] > 0) {
                    queue_pro_posx = unit_x;
                    queue_pro_posy = unit_y;
                    queue_pro_maxtime = 3;
                    queue_pro_angle = weapon_angle[i];
                    queue_pro_velocity = 20;
                    queue_pro_effect1_type = 0;
                    queue_pro_effect1 = 424;
                    queue_pro_effect1_start = 0;
                    queue_pro_effect1_iscript = ISCRIPT_FAST;
                    queue_pro_effect2_type = 0;
                    queue_pro_effect2 = 213;
                    queue_pro_effect2_start = 3;
                    queue_pro_effect2_iscript = ISCRIPT_FAST;
                    CreateProjectile();
                    weapon_angle[i] -= 20;
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 6) weapon_state[i] = 0;
            }

            // SHORT BOW
            if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_SHORTBOW) {
                if (weapon_state[i] == 1) {
                    CenterLoc(L_4x4, unit_x, unit_y);
                    if (EnemiesAtLoc(L_4x4)) weapon_state[i] = 0;
                    else {
                        weapon_x[i], weapon_y[i] = unit_order_x, unit_order_y;
                        PlayWAV("staredit/wav/bow_charge.ogg");
                    }
                }
                if (weapon_state[i] > 0 && weapon_state[i] <= 10) {
                    const distance = 66 - (weapon_state[i] * 6);
                    const angle_to_order = GetAngle(unit_x, unit_y, weapon_x[i], weapon_y[i]);
                    const image0_x, image0_y = MovePosTowards(unit_x, unit_y, angle_to_order + 70, distance);
                    const image1_x, image1_y = MovePosTowards(unit_x, unit_y, angle_to_order - 70, distance);
                    const image2_x, image2_y = MovePosTowards(unit_x, unit_y, angle_to_order, distance);
                    setloc(L_MAIN, image0_x, image0_y);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 233, 16, ISCRIPT_NORMAL);
                    setloc(L_MAIN, image1_x, image1_y);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 233, 16, ISCRIPT_NORMAL);
                    setloc(L_MAIN, image2_x, image2_y);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 233, 16, ISCRIPT_NORMAL);
                }
                if (weapon_state[i] == 11) {
                    const angle_to_order = GetAngle(unit_x, unit_y, weapon_x[i], weapon_y[i]);
                    queue_pro_owner = playerID;
                    queue_pro_weapon_id = weapon_id[i];
                    queue_pro_posx = unit_x;
                    queue_pro_posy = unit_y;
                    queue_pro_maxtime = 24;
                    queue_pro_angle = angle_to_order;
                    queue_pro_velocity = 40;
                    queue_pro_effect1 = 557;
                    queue_pro_effect1_start = 3;
                    queue_pro_effect2 = 441;
                    queue_pro_effect2_drawfunc = 16;
                    queue_pro_effect2_start = 4;
                    queue_pro_collide_enemies = 1;
                    queue_pro_collide_size = 64;
                    CreateProjectile();
                    for (var i = 0; i < 3; i++) {
                        queue_pro_posx = unit_x;
                        queue_pro_posy = unit_y;
                        queue_pro_maxtime = 6;
                        queue_pro_angle = angle_to_order;
                        queue_pro_velocity = 35;
                        queue_pro_angular_velocity = Random(-20, 20);
                        queue_pro_effect1 = 422;
                        queue_pro_effect1_drawfunc = 17;
                        queue_pro_effect2_start = queue_pro_maxtime;
                        queue_pro_effect2 = 422; // 495, 544, 963, 512
                        queue_pro_effect2_drawfunc = 12;
                        CreateProjectile();
                    }
                    PlayArrow();
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 13) weapon_state[i] = 0;
            }

            // FIRE BALL
            if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_FIREBALL) {
                const life_cost = GetWeaponLifeCost(weapon_id[i], playerID);
                if (weapon_state[i] == 1 && unit.hp > life_cost) {
                    DoMagicLifeDrainCost(playerID, unit, life_cost);
                } else if (weapon_state[i] == 1) {
                    weapon_state[i] = 0;
                }
                if (weapon_state[i] == 1) {
                    const angle_to_order = GetAngle(unit_x, unit_y, unit_order_x, unit_order_y);
                    const distance_to_order = GetDistance(unit_x, unit_y, unit_order_x, unit_order_y);
                    if (distance_to_order > 256) weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, angle_to_order, 256);
                    else weapon_x[i], weapon_y[i] = unit_order_x, unit_order_y;
                    queue_pro_posx, queue_pro_posy = MovePosTowards(weapon_x[i], weapon_y[i], 280, 366);
                    queue_pro_maxtime = 20;
                    queue_pro_angle = 100;
                    queue_pro_velocity = 20;
                    queue_pro_effect1 = 332;
                    queue_pro_effect1_start = 0;
                    queue_pro_effect2 = 333;
                    queue_pro_effect2_start = queue_pro_maxtime;
                    CreateProjectile();
                    PlayWavAtPos("staredit/wav/fireball_incoming.ogg", weapon_x[i], weapon_y[i], 512);
                    DrawCircle(weapon_x[i], weapon_y[i], 128, 24, 448, 0, ISCRIPT_NORMAL);
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 20) {
                    weapon_state[i] = 0;
                    const damage = GetWeaponDamage(weapon_id[i], weapon_state[i], playerID);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 128, damage, 8);
                    setloc(L_MAIN, weapon_x[i], weapon_y[i]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 429, 0, ISCRIPT_LONGFAST);
                    PlayWavAtPos("staredit/wav/fireball.ogg", weapon_x[i], weapon_y[i], 512);
                    display_damage = damage;
                }
            }

            // LIGHTNING BLAST
            if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_LIGHTNINGBLAST) {
                const life_cost = GetWeaponLifeCost(weapon_id[i], playerID);
                if (weapon_state[i] == 1 && unit.hp > life_cost) {
                    DoMagicLifeDrainCost(playerID, unit, life_cost);
                } else if (weapon_state[i] == 1) {
                    weapon_state[i] = 0;
                }
                if (weapon_state[i] == 1) {
                    weapon_angle[i] = GetAngle(unit_x, unit_y, unit_order_x, unit_order_y);
                    weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, weapon_angle[i], 32);
                    DrawCircle(weapon_x[i], weapon_y[i], 96, 20, 435, 16, ISCRIPT_NORMAL);
                    PlayWavAtPos("sound\Bullet\zdeAtt00.wav", weapon_x[i], weapon_y[i], 512);
                }
                if (weapon_state[i] == 20) {
                    const damage = GetWeaponDamage(weapon_id[i], 0, playerID);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 96, damage, 8);
                    display_damage = damage;
                    setloc(L_MAIN, weapon_x[i], weapon_y[i]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_PHOTON_BLASTERS, 16, ISCRIPT_NORMAL);
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_PARTICLE_BEAM, 17, ISCRIPT_NORMAL);
                    const iterations = 1;
                    for (var j = 0; j < iterations; j++) {
                        queue_pro_owner = playerID;
                        queue_pro_weapon_id = weapon_id[i];
                        queue_pro_posx, queue_pro_posy = weapon_x[i], weapon_y[i];
                        queue_pro_maxtime = 8;
                        queue_pro_angle = weapon_angle[i] + Random(-30, 30);
                        queue_pro_velocity = 60;
                        queue_pro_effect0 = IMAGE_LIGHTNING0;
                        queue_pro_effect0_start = 0;
                        queue_pro_effect1 = IMAGE_LIGHTNING1;
                        queue_pro_effect1_start = 4;
                        queue_pro_effect2 = IMAGE_LIGHTNING2;
                        queue_pro_effect2_start = queue_pro_maxtime;
                        queue_pro_collide_enemies = 1;
                        queue_pro_collide_size = 64;
                        CreateProjectile();
                    }
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 21) {
                    weapon_state[i] = 0;
                }
            }

            // ANCIENT TOME OF STAR FALL
            if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_ANCIENT_TOME_OF_STARFALL) {
                const life_cost = GetWeaponLifeCost(weapon_id[i], playerID);
                if (weapon_state[i] == 1 && unit.hp > life_cost) {
                    DoMagicLifeDrainCost(playerID, unit, life_cost);
                } else if (weapon_state[i] == 1) {
                    weapon_state[i] = 0;
                }
                if (weapon_state[i] == 1) {
                    const angle_to_order = GetAngle(unit_x, unit_y, unit_order_x, unit_order_y);
                    const distance_to_order = GetDistance(unit_x, unit_y, unit_order_x, unit_order_y);
                    if (distance_to_order > 640) weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, angle_to_order, 640);
                    else weapon_x[i], weapon_y[i] = unit_order_x, unit_order_y;
                    queue_pro_posx, queue_pro_posy = MovePosTowards(weapon_x[i], weapon_y[i], 280, 366);
                    queue_pro_maxtime = 20;
                    queue_pro_angle = 100;
                    queue_pro_velocity = 20;
                    queue_pro_effect1 = 213;
                    queue_pro_effect1_start = 0;
                    queue_pro_effect2 = 214;
                    queue_pro_effect2_start = queue_pro_maxtime;
                    CreateProjectile();
                    PlayWavAtPos("staredit/wav/fireball_incoming.ogg", weapon_x[i], weapon_y[i], 512);
                    DrawCircle(weapon_x[i], weapon_y[i], 192, 36, 448, 16, ISCRIPT_NORMAL);
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 20) {
                    weapon_state[i] = 0;
                    const damage = GetWeaponDamage(weapon_id[i], weapon_state[i], playerID);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 192, damage, 8);
                    setloc(L_MAIN, weapon_x[i], weapon_y[i]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 444, 0, ISCRIPT_LONGFAST);
                    PlayWavAtPos("staredit/wav/fireball.ogg", weapon_x[i], weapon_y[i], 512);
                    display_damage = damage;
                    for (var j = 0; j < 8; j++) {
                        queue_pro_posx = weapon_x[i];
                        queue_pro_posy = weapon_y[i];
                        queue_pro_maxtime = 8;
                        queue_pro_angle = (j + 1) * 45;
                        queue_pro_velocity = 30;
                        queue_pro_angular_velocity = Random(-10, 10);
                        queue_pro_effect1 = 448;
                        queue_pro_effect1_drawfunc = 16;
                        queue_pro_effect2 = 427;
                        queue_pro_effect2_drawfunc = 16;
                        queue_pro_effect2_start = queue_pro_maxtime;
                        CreateProjectile();
                    }
                }
            }
            if (is_player && display_damage > 0) {
                SetHudValue(playerID, display_damage, STRING_WEAPON_DAMAGE);
            }
        }
    }
}

function ResetUtilityIndex(i) {
    utility_cunit[i] = 0;
    utility_id[i] = 0;
    utility_state[i] = 0;
    utility_cooldown[i] = 0;
}
// @bm UpdateUtilityState
function UpdateUtilityState(playerID) {
    var check_from = 0;
    var check_to = 0;
    if (playerID < 6) {
        check_from = playerID;
        check_to = playerID + 1;
    } else if (playerID >= 6) {
        check_from = 6;
        check_to = MAX_UTILITY_OBJECTS;
    }
    for (var i = check_from; i < check_to; i++) {
        if (utility_id[i] > 0) {
            var unit_ptr = utility_cunit[i];
            var unit_order_x, unit_order_y = 0, 0;
            var unit_x, unit_y = 0, 0;
            if (playerID < 6) unit_ptr = p_cunit[playerID];
            const unit = CUnit(unit_ptr);
            if (playerID < 6) {
                unit_order_x, unit_order_y = p_orderx[playerID], p_ordery[playerID];
                unit_x, unit_y = p_x[playerID], p_y[playerID];
            } else if (playerID >= 6) {
                if (unit.hp == 0) {
                    ResetUtilityIndex(i);
                    continue;
                }
                unit_x = unit.posX;
                unit_y = unit.posY;
                unit_order_x = unit.orderTargetX;
                unit_order_y = unit.orderTargetY;
                // unit_angle = SCDirectionToDeg(unit.currentDirection1);
            }
            
            // TRIGGER
            if (utility_cooldown[i] > 0) utility_cooldown[i]--;
            const utility_triggered = CheckForUtilityTrigger(playerID, unit, utility_id[i]);
            if (utility_triggered && utility_cooldown[i] == 0) {
                utility_cooldown[i] = GetUtilityCooldown(utility_id[i]);
                utility_state[i] = 1;
            }

            if (utility_state[i] > 0 && utility_id[i] == UTILITY_DASH) {
                const life_cost = GetUtilityLifeCost(utility_id[i], playerID);
                if (utility_state[i] == 1 && unit.hp > life_cost) DoMagicLifeDrainCost(playerID, unit, life_cost);
                else if (utility_state[i] == 1) utility_state[i] = 0;
                if (playerID < 6 && !IsAlive(playerID)) utility_state[i] = 0;
                if (utility_state[i] == 1) {
                    utility_x[i], utility_y[i] = unit_x, unit_y;
                    utility_angle[i] = GetAngle(unit_x, unit_y, unit_order_x, unit_order_y);
                    PlayWavAtPos("staredit/wav/dash.ogg", utility_x[i], utility_y[i], 480);
                    const x, y = MovePosTowards(utility_x[i], utility_y[i], utility_angle[i], 64);
                    setloc(L_MAIN, x, y);
                    Order(U_HERO[playerID], playerID, L_ANYWHERE, Move, L_MAIN);
                }
                if (utility_state[i] > 1) {
                    col_posx, col_posy = MovePosTowards(utility_x[i], utility_y[i], utility_angle[i], 24);
                    col_terrain = 1;
                    col_shape_size = 8;
                    CheckCollision(playerID);
                    if (col_results_terrain == 0) {
                        utility_x[i], utility_y[i] = col_posx, col_posy;
                        setloc(L_MAIN, utility_x[i], utility_y[i]);
                        TeleportHeroPos(playerID, utility_x[i], utility_y[i]); // This should be made to account for computer units in the future
                        queue_pro_posx = utility_x[i];
                        queue_pro_posy = utility_y[i];
                        queue_pro_maxtime = 6;
                        queue_pro_angle = (utility_angle[i] - 180) + Random(-10, 10);
                        queue_pro_velocity = 20;
                        queue_pro_angular_velocity = Random(-5, 5);
                        queue_pro_effect1 = IMAGE_FRAG_GRENADE_HIT;
                        queue_pro_effect1_drawfunc = 6;
                        queue_pro_effect1_iscript = ISCRIPT_FAST;
                        queue_pro_effect2 = IMAGE_FRAG_GRENADE_HIT;
                        queue_pro_effect2_start = 3;
                        queue_pro_effect2_drawfunc = 17;
                        queue_pro_effect2_iscript = ISCRIPT_FAST;
                        CreateProjectile();
                    } else {
                        utility_state[i] = 12;
                    }
                    setloc(L_MAIN, utility_x[i], utility_y[i]);
                    CreateImageSpriteAtLocation(playerID, L_MAIN, IMAGE_EXPL_BLUE_SMALL, 6, ISCRIPT_FAST);
                }
                if (utility_state[i] > 0) utility_state[i]++;
                if (utility_state[i] >= 12) {
                    utility_x[i], utility_y[i] = MovePosTowards(utility_x[i], utility_y[i], utility_angle[i], 64);
                    setloc(L_MAIN, utility_x[i], utility_y[i]);
                    Order(U_HERO[playerID], playerID, L_ANYWHERE, Move, L_MAIN);
                    utility_state[i] = 0;
                }
            }
        }
    }
}

function LevelUp(playerID, unit: CUnit) {
    p_level_current[playerID] += 1;
    p_attributepoints[playerID] += 1;
    p_exp_current[playerID] = 0;
    p_exp_goal[playerID] = 300 + 150 * p_level_current[playerID];
    unit.killCount = p_level_current[playerID];
    screen.printf("LEVEL UP - Level {}", p_level_current[playerID]);
    PlayWAV("staredit/wav/levelup.ogg");
    CreateUnitDeathAtLocation($U("Protoss Observer"), $P8, L_MAIN);
    for (var i = 0; i < 8; i++) {
        queue_pro_posx = p_x[playerID];
        queue_pro_posy = p_y[playerID];
        queue_pro_maxtime = 8;
        queue_pro_angle = (i + 1) * 45;
        queue_pro_velocity = 40;
        queue_pro_angular_velocity = Random(-10, 10);
        queue_pro_effect0 = U_KAKARU;
        queue_pro_effect0_type = 1;
        queue_pro_effect1 = 213;
        queue_pro_effect1_start = queue_pro_maxtime - 1;
        queue_pro_effect2 = 427;
        queue_pro_effect2_start = queue_pro_maxtime;
        CreateProjectile();
    }
}

function FillActiveNearbyUnits(playerID, positionx, positiony) {
    var storage_i = (playerID * ACTIVE_UNITS_MAX) + 1;
    const storage_max = (playerID + 1) * ACTIVE_UNITS_MAX;
    for (var i = storage_i; i < storage_max; i++) active_units[i] = 0;
    const limit_left, limit_right, limit_top, limit_bottom = PosToSquare(positionx, positiony, ACTIVE_UNITS_RECT);
    if (IsAlive(playerID)) active_units[storage_i - 1] = p_cunit[playerID]; // set the first storage index for the player to the player's unit.
    var i = 0;
    foreach(unit : EUDLoopCUnit()) {
        if (unit.playerID == $P7 && unit.hp > 0) {
            if (IsPosWithinRect(unit.posX, unit.posY, limit_left, limit_right, limit_top, limit_bottom)) { // check if unit is within square, if it is add it to the active units array.
                active_units[storage_i] = unit;
                storage_i++;
                if (storage_i > storage_max) break;
            }
        } else if (unit.playerID == $P7 && unit.hp == 0) {
            unit.die();
        }
        i++;
        if (i > 1000) {
            DisplayTextAll("NOTICE: CHECKED MORE THAN 1000 UNITS!");
            break;
        }
    }
}
// @bm UpdateNPCs
function UpdateNPCs() {
    for (var i = 0; i < MAX_NPC_UNITS; i++) {
        if (npc_id[i] > 0) {
            const unit = CUnit(npc_cunit[i]);
            npc_x[i], npc_y[i] = unit.posX, unit.posY;
            // debug_values[0] = unit.orderID;
            if (npc_id[i] == NPC_GUARDIAN_ANGEL) {
                var unit_angle = SCDirectionToDeg(unit.currentDirection1);
                // AI
                if (npc_order_timer[i] == 0) {
                    npc_order_timer[i] = 12;
                    if (GetAreaAtPos(npc_home_x[i], npc_home_y[i]) == AREA_GATE_MOUNTAIN) {
                        var players_on_mountain = 0;
                        var aggro_x, aggro_y = 0, 0;
                        for (var p = 0; p < 6; p++) {
                            if (IsAlive(p) && GetAreaAtPos(p_x[p], p_y[p]) == AREA_GATE_MOUNTAIN) {
                                players_on_mountain = 1;
                                unit.setloc(L_MAIN);
                                setloc(L_0x0, p_x[p], p_y[p]);
                                Order(U_GUARDIAN_ANGEL, $P7, L_MAIN, Patrol, L_0x0);
                                break;
                            }
                        }
                        if (!players_on_mountain && npc_x[i] != npc_home_x[i] && npc_y[i] != npc_home_y[i]) {
                            unit.setloc(L_MAIN);
                            setloc(L_0x0, npc_home_x[i], npc_home_y[i]);
                            Order(U_GUARDIAN_ANGEL, $P7, L_MAIN, Move, L_0x0);
                        }
                    }
                }
                if (npc_order_timer[i] > 0) npc_order_timer[i]--;

                // wings
                const angular_velocity = 10;
                if (npc_state3[i] == 0) {
                    npc_state3[i] = 2;
                    queue_pro_posx = unit.posX;
                    queue_pro_posy = unit.posY;
                    queue_pro_maxtime = 6;
                    queue_pro_angle = (unit_angle + 90) + (npc_state1[i] - 100);
                    queue_pro_velocity = 40;
                    if (npc_state0[i] == 1) queue_pro_angular_velocity = -angular_velocity;
                    else if (npc_state0[i] == 2) queue_pro_angular_velocity = angular_velocity;
                    queue_pro_effect0_drawfunc = 17;
                    queue_pro_effect1_drawfunc = 17;
                    // queue_pro_effect2_drawfunc = 17;
                    queue_pro_effect0 = 468;
                    queue_pro_effect1 = 467;
                    queue_pro_effect1_start = 3;
                    queue_pro_effect2 = 466;
                    queue_pro_effect2_start = queue_pro_maxtime;
                    CreateProjectile();
                    queue_pro_posx = unit.posX;
                    queue_pro_posy = unit.posY;
                    queue_pro_maxtime = 6;
                    queue_pro_angle = (unit_angle - 90) - (npc_state1[i] - 100);
                    queue_pro_velocity = 40;
                    if (npc_state0[i] == 1) queue_pro_angular_velocity = angular_velocity;
                    else if (npc_state0[i] == 2) queue_pro_angular_velocity = -angular_velocity;
                    queue_pro_effect0_drawfunc = 17;
                    queue_pro_effect1_drawfunc = 17;
                    // queue_pro_effect2_drawfunc = 17;
                    queue_pro_effect0 = 468;
                    queue_pro_effect1 = 467;
                    queue_pro_effect1_start = 3;
                    queue_pro_effect2 = 466;
                    queue_pro_effect2_start = queue_pro_maxtime;
                    CreateProjectile();
                    const wing_speed = 4;
                    if (npc_state0[i] == 0) {
                        npc_state0[i] = 1;
                        npc_state1[i] = 100;
                    }
                    if (npc_state0[i] == 1) npc_state1[i] += wing_speed;
                    else if (npc_state0[i] == 2) npc_state1[i] -= wing_speed;
                    if (npc_state0[i] == 1 && npc_state1[i] >= 150) npc_state0[i] = 2;
                    else if (npc_state0[i] == 2 && npc_state1[i] <= 50) {
                        npc_state0[i] = 1;
                        PlayWavAtPos("staredit/wav/angel0.ogg", npc_x[i], npc_y[i], 512);
                    }
                }
                if (npc_state3[i] > 0) npc_state3[i]--;
            }
        }
    }
}

// @bm onPluginStart
function onPluginStart() {
    SetupStringArrays();
    StoreSpawnPositions();
    SpawnInitialItemUnits();
    SetupSystemUnits();
    SetupWorldInteractions();
    EUDPlayerLoop()();
        const playerID = getcurpl();
        if (playerID >= 0 && playerID < 6) {
            for (var i = 0; i < 6; i++) SetAllianceStatus(i, Ally);
            SetAllianceStatus($P7, Enemy);
            SetAllianceStatus($P8, Ally);
            SetHeroDefaults(playerID);
            if (debug_enabled) {
                p_attributepoints[playerID] = 20;
                EquipItem(ARMOR_SHATTERED_KNIGHTS, U_ARMOR, playerID);
                EquipItem(WEAPON_LIGHTNINGBLAST, U_WEAPON, playerID);
                EquipItem(UTILITY_DASH, U_UTILITY, playerID);
                GetVision($P7);
            }
            PlaySong(0);
        }
    EUDEndPlayerLoop();
    setloc(L_MAIN, 2912, 2048);
}
// @bm afterTriggerExec
function afterTriggerExec() {
    UpdateTime();
    UpdateProjectiles();
    UpdateProjectileCollisions();
    UpdateEvents();
    UpdateSigils();

    // RESET CHUNK SPAWNS
    if (time_state_changed && time_state == 0) {
        RemoveUnit(U_CHIMERA, $P7);
        RemoveUnit(U_HILL_SPINT, $P7);
        RemoveUnit(U_GUARDIAN_ANGEL, $P7);
        var reset_count = 0;
        for (var i = 0; i < 256; i++) {
            if (chunk_spawns[i] > 0) {
                chunk_spawns[i] = 0;
                reset_count += 1;
            }
        }
        // screen.printf("reset spawns for {} chunks", reset_count);
    }

    EUDPlayerLoop()();
        const playerID = getcurpl();
        // HUMAN PLAYERS
        if (playerID >= 0 && playerID < 6) {
            const unit = CUnit(p_cunit[playerID]);
            var unit_is_moving = 0;
            p_just_attacked[playerID] = 0;
            p_order_input[playerID] = 0;
            var unit_is_indoors = 0;
            var unit_took_health_damage = 0;
            if (p_interaction_prompt_delay[playerID] > 0) p_interaction_prompt_delay[playerID]--;
            if (IsAlive(playerID)) {
                p_x[playerID], p_y[playerID] = unit.posX, unit.posY;
                p_angle[playerID] = SCDirectionToDeg(unit.currentDirection1);
                p_orderx[playerID], p_ordery[playerID] = unit.orderTargetX, unit.orderTargetY;

                if (active_units_update == 0) FillActiveNearbyUnits(playerID, p_x[playerID], p_y[playerID]);
                if (unit.orderID == ORDER_HOLD || unit.orderID == ORDER_PATROL) {
                    p_order_input[playerID] = unit.orderID;
                    unit.orderID = 3;
                }
                if (p_x[playerID] == p_x_old[playerID] && p_y[playerID] == p_y_old[playerID]) {
                    unit_is_moving = 0;
                } else {
                    p_x_old[playerID] = p_x[playerID];
                    p_y_old[playerID] = p_y[playerID];
                    unit_is_moving = 1;
                }
                if (!unit_is_moving && unit.currentSpeed1 > 0) {
                    unit.currentSpeed1 = 0; // Unit stuck because of flingy movement fix.
                    unit.currentSpeed2 = 0;
                }
            }
            if (unit_is_moving && IsAlive(playerID)) {
                const x, y = GetChunkAtPos(p_x[playerID], p_y[playerID]);
                if (p_chunk_x_old[playerID] != x || p_chunk_y_old[playerID] != y) {
                    p_chunk_x_old[playerID] = x;
                    p_chunk_y_old[playerID] = y;
                    JustEnteredChunk(x, y);
                }
                p_indoors[playerID] = IsPosIndoors(p_x[playerID], p_y[playerID]);
                // check for nearby sigils
                var sigil = MAX_SIGIL_SPAWNS;
                for (var i = 0; i < MAX_SIGIL_SPAWNS; i++) {
                    if (sigil_x[i] > 0) {
                        const dist = GetDistance(p_x[playerID], p_y[playerID], sigil_x[i], sigil_y[i]);
                        if (dist <= SIGIL_DIAMETER / 2) {
                            sigil = i;
                            break;
                        }
                    }
                }
                if (sigil < MAX_SIGIL_SPAWNS && p_on_sigil[playerID] == 0) {
                    p_on_sigil[playerID] = 1;
                    p_current_sigil[playerID] = sigil;
                    DrawCircle(sigil_x[sigil], sigil_y[sigil], SIGIL_DIAMETER, 24, 443, 0, ISCRIPT_NORMAL);
                    DisplayText("\x13\x04Press \x03-<F>- \x04to Interact.");
                } else if (sigil >= MAX_SIGIL_SPAWNS && p_on_sigil[playerID] > 0) {
                    p_on_sigil[playerID] = 0;
                }
                // check for nearby world interactions
                var world_interaction_index = MAX_WORLD_INTERACTIONS;
                for (var i = 0; i < MAX_WORLD_INTERACTIONS; i++) {
                    if (world_interaction_x[i] > 0) {
                        const l, r, t, b = PosToSquare(world_interaction_x[i], world_interaction_y[i], world_interaction_size[i]);
                        if (IsPosWithinRect(p_x[playerID], p_y[playerID], l, r, t, b)) {
                            world_interaction_index = i;
                            break;
                        }
                    }
                }
                if (world_interaction_index < MAX_WORLD_INTERACTIONS && p_on_world_interaction[playerID] == 0) {
                    p_on_world_interaction[playerID] = world_interaction_index + 1;
                    setloc(L_MAIN, world_interaction_x[p_on_world_interaction[playerID] - 1], world_interaction_y[p_on_world_interaction[playerID] - 1]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_SCARAB_MISSILE, 17, ISCRIPT_FAST);
                    if (p_interaction_prompt_delay[playerID] == 0) {
                        p_interaction_prompt_delay[playerID] = 72;
                        const text = GetStringWorldInteractionPrompt(p_on_world_interaction[playerID] - 1);
                        screen.printf("{:s}", text);
                    }
                } else if (world_interaction_index >= MAX_SIGIL_SPAWNS && p_on_world_interaction[playerID] > 0) {
                    p_on_world_interaction[playerID] = 0;
                }
            }
            UpdateBrightness(playerID);
            UpdateSightRange(playerID);

            // SIGIL INTERACTION
            if (p_on_sigil[playerID] && IsAlive(playerID)) {
                if (m_main[playerID] == 0 && keypress_f[playerID] > 0) {
                    m_main[playerID] = MENU_MAIN_SIGIL;
                } else if (m_main[playerID] == MENU_MAIN_SIGIL) {
                    UpdateSigilMenu(playerID);
                }
                // set to home if this is the players first sigil
                const x, y = GetSpawnPosition(playerID);
                if (p_homepos_x[playerID] == x && p_homepos_y[playerID] == y) {
                    p_homepos_x[playerID] = sigil_x[p_current_sigil[playerID]];
                    p_homepos_y[playerID] = sigil_y[p_current_sigil[playerID]];
                }

            } else if (p_on_sigil[playerID] == 0 && m_main[playerID] > 0) {
                m_main[playerID] = 0;
                ClearTextLines(0, 9);
            }

            // WORLD INTERACTIONS
            if (p_on_world_interaction[playerID] && IsAlive(playerID)) {
                const index = p_on_world_interaction[playerID] - 1;
                /*
                BIRD PILLAR
                    North: "Where the frost-kissed feathers of the snow owl catch the first light, darkness stirs in silent anticipation."
                    East: "With the rising sun, the crane takes flight, casting shadows that guide the unborn to awaken in the warmth of the dawn."
                    South: "In the fiery embrace of the midday sun, the phoenix soars, signaling the faithful to embrace the radiant energy of the sky."
                    West: "As the day bids farewell and the heron glides towards the horizon, a secret is whispered by the western winds."
                
                WOLF PILLAR

                FISH PILLAR
                
                 */
            }

            // HEALTH
            if (IsAlive(playerID)) {
                const regen_amount = GetHealthRegen(playerID);
                HealPlayer(playerID, unit, regen_amount); // regen from strength
                if (unit.hp > p_health[playerID]) {
                    if (unit.hp > p_health_max[playerID]) unit.hp = p_health_max[playerID];
                    const health_gained = unit.hp - p_health[playerID];
                    p_health[playerID] = unit.hp;
                    // const gained_whole, gained_frac = GetWholeAndFraction((health_gained * 10000) / 256);
                    // screen.printf("{}.{} health gained", gained_whole, gained_frac);
                }
                if (unit.hp < p_health[playerID]) {
                    const health_lost = p_health[playerID] - unit.hp;
                    unit_took_health_damage = health_lost;
                    const amount_recovered = GetHealthToughnessDeduction(playerID, health_lost);
                    HealPlayer(playerID, unit, amount_recovered); // toughness from dexterity
                    p_health[playerID] = unit.hp;
                    // const recovered_whole, recovered_frac = GetWholeAndFraction((amount_recovered * 10000) / 256);
                    // screen.printf("{} health LOST! Recovered {}.{} from toughness.", health_lost / 256, recovered_whole, recovered_frac);
                }
            }

            // SHIELDS/ARMOR
            if (IsAlive(playerID)) {
                CenterLocHero(L_16x16, playerID);
                if (unit.shield != p_shield_max[playerID] && !EnemiesAtLoc(L_16x16)) HealShieldPlayer(playerID, unit, p_shield_max[playerID]);
                CenterLocHero(L_3X3, playerID);
                if (EnemiesAtLoc(L_3X3) && p_shield_recover[playerID] == 0) p_shield_recover[playerID] = 1;
                else if (!EnemiesAtLoc(L_3X3) && p_shield_recover[playerID] > 0) {
                    p_shield_recover[playerID] = 0;
                    HealShieldPlayer(playerID, unit, p_shield_max[playerID]);
                    CreateImageSpriteAtLocation($P8, L_3X3, 377, 0, ISCRIPT_NORMAL);
                    PlayWAV("staredit/wav/dodge.ogg");
                }
                if (unit.shield == p_shield_max[playerID] && p_shield_broken[playerID] > 0) p_shield_broken[playerID] = 0;
                else if (p_shield_broken[playerID] > 0) unit.shield = 0;
                if (unit.shield > p_shield[playerID]) {
                    if (unit.shield > p_shield_max[playerID]) unit.shield = p_shield_max[playerID];
                    const armor_gained = unit.shield - p_shield[playerID];
                    p_shield[playerID] = unit.shield;
                    // const gained_whole, gained_frac = GetWholeAndFraction((armor_gained * 10000) / 256);
                    // screen.printf("{}.{} armor gained", gained_whole, gained_frac);
                }
                if (unit.shield < p_shield[playerID]) {
                    const armor_lost = p_shield[playerID] - unit.shield;
                    const amount_recovered = GetArmorToughnessDeduction(playerID, armor_lost);
                    HealShieldPlayer(playerID, unit, amount_recovered); // toughness from resilience
                    if (unit_took_health_damage && p_shield[playerID] >= 256) {
                        p_shield_broken[playerID] = 1;
                        // DisplayText("\x13\x06-! ARMOR BROKEN !-");
                        PlayWAV("staredit/wav/shields_broke.ogg");
                        setloc(L_MAIN, p_x[playerID], p_y[playerID]);
                        CreateImageSpriteAtLocation($P8, L_MAIN, 107, 16, ISCRIPT_NORMAL);
                    }
                    p_shield[playerID] = unit.shield;
                    // screen.printf("{} armor LOST", armor_lost / 256);
                }
            }

            // @bm UNIT ATTACK
            if (IsAlive(playerID)) {
                if (unit.groundWeaponCooldown == 26) {
                    p_just_attacked[playerID] = 1;
                    unit.groundWeaponCooldown -= GetAttackSpeed(playerID);
                    const target = unit.orderTargetUnit;
                    var target_is_valid = 1;
                    // LOOTING
                    if (target.unitID == U_WEAPON || target.unitID == U_ARMOR || target.unitID == U_LIFEPICKUP) {
                        unit.orderID = 3;
                        p_just_attacked[playerID] = 0;
                        CenterLocHero(L_16x16, playerID);
                        ModifyUnitHitPoints(All, target.unitID, $P8, L_16x16, 100);
                        target_is_valid = 0;
                        if (UnitItemHasBeenLooted(playerID, target.shield)) {
                            DisplayText("\x13\x04You've already looted this.");
                        } else {
                            p_current_item_unit[playerID] = target;
                            PlayWAV("staredit/wav/check_item.ogg");
                        }
                        if (target.unitID == U_LIFEPICKUP) {
                            p_current_item_unit[playerID] = 0;
                            target.shield = ModifyItemLootedStatus(playerID, target.shield);
                            SetMaxHP(playerID, p_health_max[playerID] + PLAYER_LIFE_PICKUP_INCREASE);
                        }
                        if (target.shield == 0) { // remove the unit if the loot status returns 0
                            setloc(L_MAIN, target.posX, target.posY);
                            RemoveUnitAt(1, target.unitID, L_MAIN, $P8);
                        }
                    }
                    if (target_is_valid) DamageUnit(playerID, target, p_damage[playerID], ACTIVE_UNITS_MAX + 1);
                }
            }

            // LOOT MENU
            if (p_current_item_unit[playerID] > 0) {
                const item_unit = CUnit(p_current_item_unit[playerID]);
                const item_id = item_unit.energy;
                const item_looted_status = item_unit.shield;
                const item_unit_type = item_unit.unitID;
                const item_x, item_y = item_unit.posX, item_unit.posY;
                if (GetDistance(p_x[playerID], p_y[playerID], item_x, item_y) > CLOSE_LOOT_MENU_DISTANCE) {
                    ClearTextLines(0, 2);
                    p_current_item_unit[playerID] = 0;
                } else {
                    const item_name = GetStringItemName(item_id, item_unit_type);
                    const item_description = GetStringItemDescription(item_id, item_unit_type);
                    var equipped_id = 0; // whatever is currently equipped in the target slot
                    if (item_unit_type == U_WEAPON) equipped_id = weapon_id[playerID];
                    else if (item_unit_type == U_ARMOR) equipped_id = p_armor[playerID];
                    const equipped_name = GetStringItemName(equipped_id, item_unit_type);
                    screen.printfAt(0, "\x09\x09\x09\x09\x09\x09\x04--+ \x1F{:s}", item_name);
                    screen.printfAt(1, "\x09\x09\x09\x09\x09\x09\x09\x09\x02{:s}", item_description);
                    if (equipped_id > 0) {
                        screen.printfAt(2, "\x09\x09\x09\x09\x09\x09\x09\x09\x02{:s}\x1F{:s}", strings_loot_interactions[1], equipped_name);
                    } else {
                        screen.printfAt(2, "\x09\x09\x09\x09\x09\x09\x09\x09\x02{:s}", strings_loot_interactions[0]);
                    }
                    if (keypress_1[playerID]) {
                        item_unit.shield = ModifyItemLootedStatus(playerID, item_looted_status);
                        if (item_unit.shield == 0) { // remove the unit if the loot status returns 0
                            setloc(L_MAIN, item_x, item_y);
                            RemoveUnitAt(1, item_unit_type, L_MAIN, $P8);
                        }
                        if (equipped_id > 0) {
                            setloc(L_MAIN, p_x[playerID], p_y[playerID]);
                            CreateItemUnit(item_unit_type, equipped_id, L_MAIN);
                            screen.printf("\x13\x06Dropped \x1F{:s}", equipped_name);
                        }
                        EquipItem(item_id, item_unit_type, playerID);
                        p_current_item_unit[playerID] = 0;
                        ClearTextLines(0, 2);
                        screen.printf("\x13\x04Equipped \x1F{:s}", item_name);
                        PlayWAV("staredit/wav/equip_weapon.ogg");
                    }
                }
            }

            // WEAPON
            UpdateWeaponState(playerID);
            UpdateUtilityState(playerID);

            // EXP
            if (p_exp_buffer[playerID] > 0) {
                var exp_just_gained = p_exp_buffer[playerID];
                p_exp_total[playerID] += exp_just_gained;
                p_exp_current[playerID] += exp_just_gained;
                if (p_exp_current[playerID] >= p_exp_goal[playerID]) {
                    exp_just_gained = p_exp_current[playerID] - p_exp_goal[playerID];
                    p_exp_current[playerID] += exp_just_gained;
                    LevelUp(playerID, p_cunit[playerID]);
                }
                screen.printf("\x12\x1F+{} Exp \x04({} | {})\x09\x09", p_exp_buffer[playerID], p_exp_current[playerID], p_exp_goal[playerID]);
                PlayWAV("staredit/wav/gain_exp.ogg");
                p_exp_buffer[playerID] = 0;
            }
            if (Command(playerID, AtLeast, 1, U_EXPERIENCE)) {
                p_exp_lost_timer[playerID]--;
                setloc(L_MAIN, p_exp_x[playerID], p_exp_y[playerID]);
                CenterLoc(L_4x4, p_exp_x[playerID], p_exp_y[playerID]);
                if (HeroIsAt(L_4x4, playerID)) {
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_EXPL_BLUE_SMALL, 0, ISCRIPT_NORMAL);
                    RemoveUnit(U_EXPERIENCE, playerID);
                    p_exp_buffer[playerID] += p_exp_lost[playerID];
                    p_exp_lost[playerID] = 0;
                }
                if (experience_ping_timer == 0) {
                    MinimapPing(L_MAIN);
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_HALLUC_DEATH1, 0, ISCRIPT_NORMAL);
                }
                if (p_exp_lost_timer[playerID] == 0) {
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_EXPL_BLUE_SMALL, 0, ISCRIPT_NORMAL);
                    RemoveUnit(U_EXPERIENCE, playerID);
                    DisplayText("\x13\x04Your dropped experience has vanished.");
                }
            }

            // TIME
            if (time_state_changed) {
                if (time_state == 0) {
                    PlaySong(0);
                }
                else if (time_state == 1) {
                    PlayWAV("staredit/wav/night_ambience.ogg");
                    PlayWAV("staredit/wav/night.ogg");
                    // PlayWAV("staredit/wav/blood_moon_ambience.ogg");
                }
            }

            // @bm DEATH
            if (!debug_enabled && total_time < 144) p_death_state[playerID] = 70;
            if (!IsAlive(playerID)) {
                p_death_state[playerID]++;
                if (debug_enabled) p_death_state[playerID] = 72;
                if (Deaths(playerID, AtLeast, 1, U_HERO[playerID])) {
                    SetDeaths(playerID, SetTo, 0, U_HERO[playerID]);
                    setloc(L_MAIN, p_x[playerID], p_y[playerID]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_PLAGUE_CLOUD, 0, ISCRIPT_LONGFAST);
                    CenterView(L_MAIN);
                    DisplayText("\x13\x06- YOU DIED -");
                    if (p_exp_current[playerID] > 0) {
                        RemoveUnit(U_EXPERIENCE, playerID);
                        CreateUnitWithProperties(1, U_EXPERIENCE, L_MAIN, playerID, UnitProperty(invincible = true));
                        p_exp_lost[playerID] = p_exp_current[playerID];
                        p_exp_lost_timer[playerID] = 2880;
                        p_exp_current[playerID] = 0;
                        p_exp_x[playerID], p_exp_y[playerID] = p_x[playerID], p_y[playerID];
                        screen.printf("\x13\x04Lost \x1F{} \x04Experience!", p_exp_lost[playerID]);
                    }
                }
                if (p_death_state[playerID] >= 72) {
                    p_death_state[playerID] = 0;
                    SpawnHero(playerID);
                    if (IsUserCP()) {
                        screen.printf("\x13\x1FHint: \x02{:s}", GetStringHint(p_current_death_hint));
                        p_current_death_hint++;
                    }
                    
                }
            }

            // HUD
            if (hud_value_timer[playerID] > 0) {
                hud_value_timer[playerID]--;
                if (m_main[playerID] == 0) {
                    screen.printfAt(0, "{:s}{}", hud_value_string[playerID], hud_value[playerID]);
                    if (hud_value_timer[playerID] == 0) DisplayTextAt(0, "\x0BNull");
                }
            }

            // @bm debug_enabled
            if (debug_enabled) {
                if (p_on_sigil[playerID]) {
                    HealPlayer(playerID, unit, 256);
                }
                debug_values[6] = p_x[playerID];
                debug_values[7] = p_y[playerID];
                eprintf("{} | {} | {} | {} | {} | {} | {} | {}", debug_values[0], debug_values[1], debug_values[2], debug_values[3], debug_values[4], debug_values[5], debug_values[6], debug_values[7]);
            }
        }

        // PLAYER 7 - MONSTERS
        if (playerID == $P7) {
            UpdateWeaponState(playerID);
        }
    EUDEndPlayerLoop();

    UpdateNPCs();

    if (!debug_enabled) {
        if (total_time == 48) {
            ClearTextLines(0, 10);
            DisplayTextAllAt(5, "\x13\x06SPIRIT KNIGHTS");
        }
        if (total_time == 120) {
            ClearTextLines(0, 10);
            DisplayTextAllAt(5, "\x13\x04You wake up.");
        }
    }

    if (active_units_update == 0) active_units_update = 24;
    active_units_update -= 1;
    if (experience_ping_timer == 0) experience_ping_timer = 72;
    experience_ping_timer -= 1;
}