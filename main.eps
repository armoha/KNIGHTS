
const L_ANYWHERE = $L("Anywhere");
const L_MAIN = $L("main");
const L_3X3 = $L("3x3");
const L_16x16 = $L("16x16");

const U_HERO = [61, 62, 64, 69, 60, 86];
const U_CHIMERA = 37;
const U_ANY = 229;
const U_KAKARU = 94;
const U_SCOURGE = 47;

const ORDER_HOLD = 107;
const ORDER_PATROL = 152;

const FULL_DAY_LENGTH = 8640;
const BRIGHTNESS_DEFAULT = 31;
const BRIGHTNESS_NIGHT = 25;
const ELEVATION_DEFAULT = 4;
const ACTIVE_UNITS_MAX = 40;
const ACTIVE_UNITS_RECT = 960;

const PLAYER_DEFAULT_HP = 100;
const PLAYER_DEFAULT_SIGHT = 8;
const PLAYER_DEFAULT_ARMOR = 100;
const PLAYER_DEFAULT_DAMAGE = 6;

const CHIMERA_EXP = 30;

const p_cunit = PVariable();
const p_pos_x_old = PVariable();
const p_pos_y_old = PVariable();
const p_chunk_x_old = PVariable();
const p_chunk_y_old = PVariable();
const p_armor_max = PVariable();
const p_armor_recover = PVariable();
const p_armor_old = PVariable();
const p_attackspeed = PVariable();
const p_damage = PVariable();
const p_brightness = PVariable();
const p_health_max = PVariable();
const p_exp_current = PVariable();
const p_exp_goal = PVariable();
const p_level_current = PVariable();
const p_weapon_id = PVariable();
const p_weapon_cooldown = PVariable();
const p_homepos_x = PVariable();
const p_homepos_y = PVariable();
const p_indoors = PVariable();

const screen = StringBuffer(256);
const monster_spawn_type = EUDArray(1000);
const monster_spawn_x = EUDArray(1000);
const monster_spawn_y = EUDArray(1000);
const chunk_spawns = EUDArray(256);
const chunk_buffer = EUDArray(8);
const active_units = EUDArray(ACTIVE_UNITS_MAX * 6);
var active_units_update = 0;

var debug_enabled = 1;
const debug_values = EUDArray(8);
var time = 0;
var time_state = 0;
var time_state_changed = 0;
var days_elapsed = 0;
var test_delay = 0;


function CenterLoc(location, x, y) {
    setloc(L_MAIN, x, y);
    MoveLocation(location, $U("Map Revealer"), $P12, L_MAIN);
}

function CenterLocHero(location, playerID) {
    MoveLocation(location, U_HERO[playerID], playerID, L_ANYWHERE);
}

function EnemiesAtLoc(location) {
    if (Bring(Foes, AtLeast, 1, U_ANY, location)) return 1;
    return 0;
}

function GetVision(playerID) {
    if (playerID == 0) RunAIScript("+Vi0");
    else if (playerID == 1) RunAIScript("+Vi1");
    else if (playerID == 2) RunAIScript("+Vi2");
    else if (playerID == 3) RunAIScript("+Vi3");
    else if (playerID == 4) RunAIScript("+Vi4");
    else if (playerID == 5) RunAIScript("+Vi5");
    else if (playerID == 6) RunAIScript("+Vi6");
    else if (playerID == 7) RunAIScript("+Vi7");
}

function LoseVision(playerID) {
    if (playerID == 0) RunAIScript("-Vi0");
    else if (playerID == 1) RunAIScript("-Vi1");
    else if (playerID == 2) RunAIScript("-Vi2");
    else if (playerID == 3) RunAIScript("-Vi3");
    else if (playerID == 4) RunAIScript("-Vi4");
    else if (playerID == 5) RunAIScript("-Vi5");
    else if (playerID == 6) RunAIScript("-Vi6");
    else if (playerID == 7) RunAIScript("-Vi7");
}

function GetLocationPoint(location) {
	const locTable = EPD(0x58DC4C);
	return dwread_epd(locTable + location * 5), dwread_epd(locTable + location * 5 + 1);
}

function CreateUnitDeathAtLocation(Unit, playerID, location) {
    CreateUnit(1, Unit, location, playerID);
    KillUnit(Unit, playerID);
}

function StoreSpawnPositions() {
    var i = 0;
    foreach(unit : EUDLoopCUnit()) {
        if (unit.playerID == $P9) {
            monster_spawn_type[i] = unit.unitType;
            monster_spawn_x[i] = unit.posX;
            monster_spawn_y[i] = unit.posY;
            unit.remove();
            i++;
            if (i > 1000) {
                DisplayTextAll("NOTICE: MAXIMUM SPAWN POSITIONS REACHED!");
                break;
            }
        }
    }
}

function GetChunkID(chunkX, chunkY) {
    // returns a value 1 -> 256, from coordinates 1 -> 256
    if (chunkX > 0 && chunkX <= 16 && chunkY > 0 && chunkY <= 16) {
        return (chunkY - 1) * 16 + chunkX;
    }
    // printAll("ERROR: INVALID CHUNK COORDINATES!");
    return 0;
}

function GetChunkCoords(chunkID) {
    // returns coordinates 1 -> 256 from an id 1 -> 256
    var chunkx, chunky = 0, 0;
    if (chunkID > 16 && chunkID <= 256) {
        chunkx = ((chunkID - 1) % 16) + 1;
        chunky = ((chunkID - 1) / 16) + 1;
    } else if (chunkID > 0 && chunkID <= 16) {
        chunkx = chunkID;
        chunky = 1;
    }
    // printAll("ERROR: INVALID CHUNK COORDINATES FROM ID!");
    return chunkx, chunky;
}

function FillChunkBuffer(chunkX, chunkY) {
    // fills chunk buffer array with ids of the 8 surrounding chunks, ids are zero if not valid like at the edge of the map
    // starts top and goes clockwise.
    for (var i = 0; i < 8; i++) chunk_buffer[i] = 0;
    chunk_buffer[0] = GetChunkID(chunkX, chunkY - 1);
    chunk_buffer[1] = GetChunkID(chunkX + 1, chunkY - 1);
    chunk_buffer[2] = GetChunkID(chunkX + 1, chunkY);
    chunk_buffer[3] = GetChunkID(chunkX + 1, chunkY + 1);
    chunk_buffer[4] = GetChunkID(chunkX, chunkY + 1);
    chunk_buffer[5] = GetChunkID(chunkX - 1, chunkY + 1);
    chunk_buffer[6] = GetChunkID(chunkX - 1, chunkY);
    chunk_buffer[7] = GetChunkID(chunkX - 1, chunkY - 1);
}

function SpawnUnitsAtChunk(chunkX, chunkY) {
    const limit_left = ((chunkX - 1) * 16) * 32;
    const limit_right = limit_left + 512;
    const limit_top = ((chunkY - 1) * 16) * 32;
    const limit_bottom = limit_top + 512;
    for (var i = 0; i < 1000; i++) {
        if (monster_spawn_x[i] >= limit_left && monster_spawn_x[i] < limit_right && monster_spawn_y[i] >= limit_top && monster_spawn_y[i] < limit_bottom) {
            if (monster_spawn_type[i] > 0) {
                setloc(L_MAIN, monster_spawn_x[i], monster_spawn_y[i]);
                CreateUnit(1, monster_spawn_type[i], L_MAIN, $P7);
            }
        }
    }
    chunk_spawns[GetChunkID(chunkX, chunkY) - 1] += 1;
}

function JustEnteredChunk(chunkX, chunkY) {
    FillChunkBuffer(chunkX, chunkY);
    // screen.printfAt(8, "{} | {} | {}", chunk_buffer[7], chunk_buffer[0], chunk_buffer[1]);
    // screen.printfAt(9, "{} | -- | {}", chunk_buffer[6], chunk_buffer[2]);
    // screen.printfAt(10, "{} | {} | {}", chunk_buffer[5], chunk_buffer[4], chunk_buffer[3]);
    for (var i = 0; i < 8; i++) {
        if (chunk_buffer[i] > 0 && chunk_spawns[chunk_buffer[i] - 1] == 0) {
            const x, y = GetChunkCoords(chunk_buffer[i]);
            SpawnUnitsAtChunk(x, y);
        }
    }
}

function GetChunkAtPos(positionx, positiony) {
    var chunk_pos_x = (positionx / 32) / 16;
    var chunk_pos_y = (positiony / 32) / 16;
    return chunk_pos_x + 1, chunk_pos_y + 1;
}

function CreateCUnit(unitType, playerID, location) : CUnit {
	const newUnit = CUnit.from_read(EPD(0x628438));
	CreateUnit(1, unitType, location, playerID);
	return newUnit;
}

function IsPosWithinRect(positionx, positiony, left, right, top, bottom) {
    if (positionx >= left && positionx <= right && positiony >= top && positiony <= bottom) return 1;
    return 0;
}

function IsAlive(playerID) {
    if (Command(playerID, AtLeast, 1, U_HERO[playerID])) return true;
    return false;
}

function IsPosIndoors(positionx, positiony) {
    if (IsPosWithinRect(positionx, positiony, 3840, 4390, 1630, 2340)) return 1;
    return 0;
}

function CreateImageSpriteAtLocation(playerID, location, imageID, drawFunc) {
    const new_script = 281;
    const prev_script = dwread(0x666778 + 34000 + imageID * 4);
    dwwrite(0x666778 + 34000 + imageID * 4, new_script); // change image iscript
    dwwrite(0x666778 + 14000 + imageID * 1, drawFunc); // change image drawfunc
	SetMemoryX(0x00666458, SetTo, imageID, 0x0000ffff); // change scanner image to input image
    CreateUnit(1, 33, location, playerID);
	RemoveUnit(33, playerID);
	SetMemoryX(0x00666458, SetTo, 546, 0x0000ffff); // revert scanner image
    dwwrite(0x666778 + 34000 + imageID * 4, prev_script); // revert image iscript
}

function DamageUnit(unit:CUnit, damage, index) {
	if (unit.hp < damage * 256) unit.hp = 0;
	if (unit.hp == 0) {
        if (unit.playerID == $P7 && index <= ACTIVE_UNITS_MAX) active_units[index] = 0;
        unit.die();
        return 0;
    } else {
        unit.hp -= damage * 256;
        return 1;
    }
    
}

function SCDirectionToDeg(direction) {
    var angle = direction * 14063;
    angle = (angle/10000) - 90; // could make this number readable in the future by keeping it in the range of 0 - 359
    return angle;
}

function GetAngle(originx, originy, destinationx, destinationy) {
    const angle = atan2(destinationy - originy, destinationx - originx);
    return angle;
}

function AddAngles(angle0, angle1) {
    var new_angle = angle0 + angle1;
    if (new_angle > 4000000000) new_angle += 360;
    else if (new_angle >= 360) new_angle -= 360;
    return new_angle;
}

function MovePosTowards(positionx, positiony, angle, distance) {
    const directionx, directiony = lengthdir(distance, angle);
    const new_positionx = positionx + directionx;
    const new_positiony = positiony + directiony;
    return new_positionx, new_positiony;
}

function Random(min, max) {
   return min + dwrand() / (4294967295 / (max - min + 1) + 1);
}

function PosIsOnMap(positionx, positiony) {
    if (positionx >= 0 && positionx <= 8191 && positiony >= 0 && positiony <= 8191) return 1;
    return 0;
}

function PosToSquare(positionx, positiony, width) {
    const half_width = width/2;
    var limit_left = 0;
    if (positionx > half_width) limit_left = positionx - half_width;
    const limit_right = positionx + half_width;
    var limit_top = 0;
    if (positiony > half_width) limit_top = positiony - half_width;
    const limit_bottom = positiony + half_width;
    return limit_left, limit_right, limit_top, limit_bottom;
}

function SpawnHero(playerID, location) {
    if (IsAlive(playerID)) RemoveUnit(U_HERO[playerID], playerID);
    p_cunit[playerID] = CreateCUnit(U_HERO[playerID], playerID, location);
    if (p_homepos_x[playerID] == 0) p_homepos_x[playerID], p_homepos_y[playerID] = GetLocationPoint(L_MAIN);
}

function SetMaxHP(playerID, value) {
    p_health_max[playerID] = value;
    dwwrite(0x65FD00 + 9808 + U_HERO[playerID] * 4, value * 256);
    ModifyUnitHitPoints(1, U_HERO[playerID], playerID, L_ANYWHERE, 100);
    // CenterLocHero(L_MAIN, playerID);
    // SpawnHero(playerID, L_MAIN);
}

function SetHeroDefaults(playerID) {
    p_exp_goal[playerID] = 30;
    p_armor_max[playerID] = PLAYER_DEFAULT_ARMOR * 256;
    p_damage[playerID] = PLAYER_DEFAULT_DAMAGE;
    SetMaxHP(playerID, PLAYER_DEFAULT_HP);
}

function RedeemUnitExp(playerID, Unit) {
    if (Unit == U_CHIMERA) {
        p_exp_current[playerID] += CHIMERA_EXP;
    }
}

const PROJECTILE_POOL = 192;
const pro_posx = EUDArray(PROJECTILE_POOL);
const pro_posy = EUDArray(PROJECTILE_POOL);
const pro_time = EUDArray(PROJECTILE_POOL);
const pro_maxtime = EUDArray(PROJECTILE_POOL);
const pro_angle = EUDArray(PROJECTILE_POOL);
const pro_velocity = EUDArray(PROJECTILE_POOL);
const pro_angular_velocity = EUDArray(PROJECTILE_POOL);
const pro_orbit = EUDArray(PROJECTILE_POOL);
const pro_orbit_velocity = EUDArray(PROJECTILE_POOL);
const pro_orbit_dist = EUDArray(PROJECTILE_POOL);
const pro_effect0_type = EUDArray(PROJECTILE_POOL); //whether the effect is an image or a unit death
const pro_effect0 = EUDArray(PROJECTILE_POOL);
const pro_effect0_start = EUDArray(PROJECTILE_POOL);
const pro_effect1_type = EUDArray(PROJECTILE_POOL);
const pro_effect1 = EUDArray(PROJECTILE_POOL);
const pro_effect1_start = EUDArray(PROJECTILE_POOL);
const pro_effect2_type = EUDArray(PROJECTILE_POOL);
const pro_effect2 = EUDArray(PROJECTILE_POOL);
const pro_effect2_start = EUDArray(PROJECTILE_POOL);
function ResetProjectile(i) {
    pro_time[i] = 0;
    pro_maxtime[i] = 0;
    pro_posx[i] = 0;
    pro_posy[i] = 0;
    pro_angle[i] = 0;
    pro_velocity[i] = 0;
    pro_angular_velocity[i] = 0;
    pro_orbit[i] = 0;
    pro_orbit_velocity[i] = 0;
    pro_orbit_dist[i] = 0;
    pro_effect0_type[i] = 0;
    pro_effect0[i] = 0;
    pro_effect0_start[i] = 0;
    pro_effect1_type[i] = 0;
    pro_effect1[i] = 0;
    pro_effect1_start[i] = 0;
    pro_effect2_type[i] = 0;
    pro_effect2[i] = 0;
    pro_effect2_start[i] = 0;
}

var queue_pro_posx = 0;
var queue_pro_posy = 0;
var queue_pro_time = 0;
var queue_pro_maxtime = 0;
var queue_pro_angle = 0;
var queue_pro_velocity = 0;
var queue_pro_angular_velocity = 0;
var queue_pro_orbit = 0;
var queue_pro_orbit_velocity = 0;
var queue_pro_orbit_dist = 0;
var queue_pro_effect0_type = 0;
var queue_pro_effect0 = 0;
var queue_pro_effect0_start = 0;
var queue_pro_effect1_type = 0;
var queue_pro_effect1 = 0;
var queue_pro_effect1_start = 0;
var queue_pro_effect2_type = 0;
var queue_pro_effect2 = 0;
var queue_pro_effect2_start = 0;
function ResetProjectileQueue() {
    queue_pro_posx = 0;
    queue_pro_posy = 0;
    queue_pro_time = 0;
    queue_pro_maxtime = 0;
    queue_pro_angle = 0;
    queue_pro_velocity = 0;
    queue_pro_angular_velocity = 0;
    queue_pro_orbit = 0;
    queue_pro_orbit_velocity = 0;
    queue_pro_orbit_dist = 0;
    queue_pro_effect0_type = 0;
    queue_pro_effect0 = 0;
    queue_pro_effect0_start = 0;
    queue_pro_effect1_type = 0;
    queue_pro_effect1 = 0;
    queue_pro_effect1_start = 0;
    queue_pro_effect2_type = 0;
    queue_pro_effect2 = 0;
    queue_pro_effect2_start = 0;
}

function CreateProjectile() {
    for (var i = 0; i < PROJECTILE_POOL; i++) {
        if (pro_time[i] == 0) {
            pro_time[i] = 1;
            pro_maxtime[i] = queue_pro_maxtime;
            pro_posx[i] = queue_pro_posx;
            pro_posy[i] = queue_pro_posy;
            pro_angle[i] = queue_pro_angle;
            pro_velocity[i] = queue_pro_velocity;
            pro_angular_velocity[i] = queue_pro_angular_velocity;
            pro_orbit[i] = queue_pro_angle;
            pro_orbit_velocity[i] = queue_pro_orbit_velocity;
            pro_orbit_dist[i] = queue_pro_orbit_dist;
            pro_effect0_type[i] = queue_pro_effect0_type;
            pro_effect0[i] = queue_pro_effect0;
            pro_effect0_start[i] = queue_pro_effect0_start;
            pro_effect1_type[i] = queue_pro_effect1_type;
            pro_effect1[i] = queue_pro_effect1;
            pro_effect1_start[i] = queue_pro_effect1_start;
            pro_effect2_type[i] = queue_pro_effect2_type;
            pro_effect2[i] = queue_pro_effect2;
            pro_effect2_start[i] = queue_pro_effect2_start;
            ResetProjectileQueue();
            break;
        }
    }
}

function UpdateProjectiles() {
    for (var i = 0; i < PROJECTILE_POOL; i++) {
        if (pro_time[i] > 0) {
            pro_time[i] += 1;
            pro_angle[i] = AddAngles(pro_angle[i], pro_angular_velocity[i]);
            const new_posx, new_posy = MovePosTowards(pro_posx[i], pro_posy[i], pro_angle[i], pro_velocity[i]);
            pro_posx[i] = new_posx;
            pro_posy[i] = new_posy;

            pro_orbit[i] = AddAngles(pro_orbit[i], pro_orbit_velocity[i]);
            const offsetx, offsety = MovePosTowards(new_posx, new_posy, pro_orbit[i], pro_orbit_dist[i]);
            setloc(L_MAIN, offsetx, offsety);
            //IMAGES
            if (PosIsOnMap(offsetx, offsety) ) {
                if (pro_time[i] >= pro_effect0_start[i] && pro_time[i] < pro_effect1_start[i]) {
                    // time for effect 0
                    if (pro_effect0_type[i] == 0) CreateImageSpriteAtLocation($P8, L_MAIN, pro_effect0[i], 0);
                    else CreateUnitDeathAtLocation(pro_effect0[i], $P8, L_MAIN);
                } else if (pro_time[i] >= pro_effect1_start[i] && pro_time[i] < pro_effect2_start[i]) {
                    // time for effect 1
                    if (pro_effect1_type[i] == 0) CreateImageSpriteAtLocation($P8, L_MAIN, pro_effect1[i], 0);
                    else CreateUnitDeathAtLocation(pro_effect1[i], $P8, L_MAIN);
                } else if (pro_time[i] >= pro_effect2_start[i]) {
                    // time for effect 2
                    if (pro_effect2_type[i] == 0) CreateImageSpriteAtLocation($P8, L_MAIN, pro_effect2[i], 0);
                    else CreateUnitDeathAtLocation(pro_effect2[i], $P8, L_MAIN);
                }
            }
            if (pro_time[i] >= pro_maxtime[i]) {
                ResetProjectile(i);
            }
        }
    }
}

var col_posx = 0;
var col_posy = 0;
var col_enemies = 0;
var col_allies = 0;
var col_terrain = 0; // check if the posx, posy is unpathable.
var col_shape = 0; // determines if the check will be for circle or square. Shape only works for units. 
var col_shape_size = 0; // width of the square, or diameter of the circle.
var col_max_results = 0;
const col_results_unit = EUDArray(8);
const col_results_unit_activei = EUDArray(8); // index position of the unit in the active units array, this is for deleting it from the active units array if it dies.
var col_results_unit_i = 0;
var col_results_terrain = 0;
function AddUnitToColResults(value, indexfromactive) {
    if (col_results_unit_i < col_max_results) {
        col_results_unit[col_results_unit_i] = value;
        col_results_unit_activei[col_results_unit_i] = indexfromactive;
        col_results_unit_i++;
        return 0;
    } else {
        return 1;
    } // returns 0 if results are not full, returns 1 if results are full
}

function ResetCheckCollision() {
    col_posx = 0;
    col_posy = 0;
    col_enemies = 0;
    col_allies = 0;
    col_terrain = 0;
    col_shape = 0;
    col_shape_size = 0;
    col_max_results = 0;
    for (var i = 0; i < 8; i++) col_results_unit[i] = 0;
    for (var i = 0; i < 8; i++) col_results_unit_activei[i] = 0;
    col_results_unit_i = 0;
    col_results_terrain = 0;
}

function CheckCollision(playerID) {
    // checks for things according to the configuration of the above vars. use results vars for the results of the check.
    var result_exists = 0;
    if (col_enemies) {
        if (col_shape == 0) {
            const l, r, t, b = PosToSquare(col_posx, col_posy, col_shape_size);
            for (var u = playerID * ACTIVE_UNITS_MAX; u < playerID + 1 * ACTIVE_UNITS_MAX; u++) {
                if (active_units[u] > 0) {
                    const unit = CUnit(active_units[u]);
                    if (IsPosWithinRect(unit.posX, unit.posY, l, r, t, b)) {
                        result_exists = 1;
                        const full = AddUnitToColResults(active_units[u], u);
                        if (full) break;
                    }
                }
            }
        } else if (col_shape == 1) {

        }
    }
    return result_exists;
}

const EVENT_POOL = 192;
const event_posx = EUDArray(EVENT_POOL);
const event_posy = EUDArray(EVENT_POOL);
const event_time = EUDArray(EVENT_POOL);
const event_maxtime = EUDArray(EVENT_POOL);
const event_size = EUDArray(EVENT_POOL);
const event_heal = EUDArray(EVENT_POOL);
const event_damage = EUDArray(EVENT_POOL);
const event_owner = EUDArray(EVENT_POOL);
function ResetEvent(i) {
    event_posx[i] = 0;
    event_posy[i] = 0;
    event_time[i] = 0;
    event_maxtime[i] = 0;
    event_size[i] = 0;
    event_heal[i] = 0;
    event_damage[i] = 0;
    event_owner[i] = 0;
}

var queue_event_posx = 0;
var queue_event_posy = 0;
var queue_event_time = 0;
var queue_event_maxtime = 0;
var queue_event_size = 0;
var queue_event_heal = 0;
var queue_event_damage = 0;
var queue_event_owner = 0;
function ResetEventQueue() {
    queue_event_posx = 0;
    queue_event_posy = 0;
    queue_event_time = 0;
    queue_event_maxtime = 0;
    queue_event_size = 0;
    queue_event_heal = 0;
    queue_event_damage = 0;
    queue_event_owner = 0;
}

function CreateEvent() {
    for (var i = 0; i < EVENT_POOL; i++) {
        if (event_time[i] == 0) {
            event_time[i] = 1;
            event_posx[i] = queue_event_posx;
            event_posy[i] = queue_event_posy;
            event_maxtime[i] = queue_event_maxtime;
            event_size[i] = queue_event_size;
            event_heal[i] = queue_event_heal;
            event_damage[i] = queue_event_damage;
            event_owner[i] = queue_event_owner;
            ResetEventQueue();
            break;
        }
    }
}

function UpdateEvents() {
    for (var i = 0; i < EVENT_POOL; i++) {
        if (event_time[i] > 0) {
            const playerID = event_owner[i];
            col_posx = event_posx[i];
            col_posy = event_posy[i];
            col_shape_size = event_size[i];
            col_max_results = 8;
            col_enemies = 1;
            const result_exists = CheckCollision(playerID);
            if (result_exists) {
                for (var result_i = 0; result_i < col_max_results; result_i++) {
                    const target = CUnit(col_results_unit[result_i]);
                    const target_state = DamageUnit(target, event_damage[i], col_results_unit_activei[result_i]);
                    if (target_state == 0) {
                        RedeemUnitExp(playerID, target.unitType);
                    }
                    setloc(L_MAIN, target.posX, target.posY);
                    CreateUnitDeathAtLocation(U_SCOURGE, playerID, L_MAIN);
                }
            }
            ResetCheckCollision();
            event_time[i]++;
            if (event_time[i] >= event_maxtime[i]) {
                ResetEvent(i);
            }
        }
    }
}

function UpdateTime() {
    time_state_changed = 0;
    time += 1;
    if (time > FULL_DAY_LENGTH) {
        time = 0; 
        time_state = 0;
        time_state_changed = 1;
        days_elapsed += 1;
    } else if (time_state == 0 && time >= FULL_DAY_LENGTH/2) {
        time_state = 1;
        time_state_changed = 1;
    }
}

var fow_state;
function UpdateFOW() {
    if (fow_state == 0) {
        fow_state = 1;
        SetMemory(0x0051CE98, SetTo, 0);
    } else {
        fow_state = 0;
        SetMemory(0x0051CE98, SetTo, 1);
    }
}

function UpdateBrightness(playerID) {
    var target_brightness = BRIGHTNESS_DEFAULT;
    if (time_state == 1) target_brightness = BRIGHTNESS_NIGHT;
    if (p_indoors[playerID]) target_brightness -= 6;
    if (p_brightness[playerID] < target_brightness) p_brightness[playerID] += 1;
    else if (p_brightness[playerID] > target_brightness) p_brightness[playerID] -= 1;
    if (IsUserCP()) SetMemoryEPD(EPD(0x657A9C), SetTo, p_brightness[playerID]);
}

function UpdateSightRange(playerID) {
    var target_value = PLAYER_DEFAULT_SIGHT;
    if (time_state == 1) target_value = PLAYER_DEFAULT_SIGHT - 4;
    if (p_indoors[playerID] && time_state == 0) target_value = 2;
    else if (p_indoors[playerID]) target_value = 1;
    bwrite(0x65FD00 + 13624 + U_HERO[playerID] * 1, target_value);
}

function LevelUp(playerID) {
    p_level_current[playerID] += 1;
    p_exp_current[playerID] = 0;
    p_exp_goal[playerID] = 300 + 150 * p_level_current[playerID];
    screen.printf("LEVEL UP - Level {}", p_level_current[playerID]);
    PlayWAV("staredit/wav/levelup.ogg");
    const unit = CUnit(p_cunit[playerID]);
    setloc(L_MAIN, unit.posX, unit.posY);
    CreateUnitDeathAtLocation($U("Protoss Observer"), playerID, L_MAIN);
    for (var i = 0; i < 8; i++) {
        queue_pro_posx = unit.posX;
        queue_pro_posy = unit.posY;
        queue_pro_maxtime = 8;
        queue_pro_angle = (i + 1) * 45;
        queue_pro_velocity = 40;
        queue_pro_angular_velocity = Random(-10, 10);
        queue_pro_effect0 = U_KAKARU;
        queue_pro_effect0_type = 1;
        queue_pro_effect1 = 213;
        queue_pro_effect1_start = queue_pro_maxtime - 1;
        queue_pro_effect2 = 427;
        queue_pro_effect2_start = queue_pro_maxtime;
        CreateProjectile();
    }
}

function PlaySong(id) {
    if (id == 0) PlayWAV("staredit/wav/song0.ogg");
}

function FillActiveNearbyUnits(playerID, positionx, positiony) {
    var storage = playerID * ACTIVE_UNITS_MAX;
    const storage_max = (playerID + 1) * ACTIVE_UNITS_MAX;
    for (var i = storage; i < storage_max; i++) active_units[i] = 0;
    const limit_left, limit_right, limit_top, limit_bottom = PosToSquare(positionx, positiony, ACTIVE_UNITS_RECT);
    var i = 0;
    foreach(unit : EUDLoopCUnit()) {
        if (unit.playerID == $P7 && unit.hp > 0) {
            // check if unit is within square, if it is add it to the active units array.
            if (IsPosWithinRect(unit.posX, unit.posY, limit_left, limit_right, limit_top, limit_bottom)) {
                active_units[storage] = unit;
                storage++;
                if (storage > storage_max) break;
            }
            i++;
            if (i > 1000) {
                DisplayTextAll("NOTICE: CHECKED MORE THAN 1000 P7 UNITS!");
                break;
            }
        }
    }
}


function onPluginStart() {
    StoreSpawnPositions();
    EUDPlayerLoop()();
        const playerID = getcurpl();
        if (playerID >= 0 && playerID < 6) {
            for (var i = 0; i < 6; i++) SetAllianceStatus(i, Ally);
            SetAllianceStatus($P7, Enemy);
            SetHeroDefaults(playerID);
            if (Command(playerID, AtLeast, 1, U_HERO[0])) {
                MoveLocation(L_MAIN, U_HERO[0], playerID, L_ANYWHERE);
                RemoveUnit(U_HERO[0], playerID);
                SpawnHero(playerID, L_MAIN);
                CenterView(L_MAIN);
            }
            PlaySong(0);
            // GetVision($P7);
        }
    EUDEndPlayerLoop();
}

function afterTriggerExec() {
    UpdateTime();
    UpdateProjectiles();
    UpdateEvents();
    // UpdateFOW();
    //reset chunk spawn amount
    if (time_state_changed && time_state == 0) {
        var reset_count = 0;
        for (var i = 0; i < 256; i++) {
            if (chunk_spawns[i] > 0) {
                chunk_spawns[i] = 0;
                reset_count += 1;
            }
        }
        screen.printf("reset spawns for {} chunks", reset_count);
    }
    if (test_delay > 0) test_delay -= 1;
    EUDPlayerLoop()();
        const playerID = getcurpl();
        if (playerID >= 0 && playerID < 6) {
            const unit = CUnit(p_cunit[playerID]);
            const unit_x, unit_y = unit.posX, unit.posY;
            var order_input = 0;
            var unit_is_moving = 0;
            var unit_just_attacked = 0;
            var unit_is_indoors = 0;

            if (active_units_update == 0) FillActiveNearbyUnits(playerID, unit_x, unit_y);

            if (unit.orderID == ORDER_HOLD || unit.orderID == ORDER_PATROL) {
                order_input = unit.orderID;
                unit.orderID = 3;
            }
            if (unit_x == p_pos_x_old[playerID] && unit_y == p_pos_y_old[playerID]) {
                unit_is_moving = 0;
            } else {
                p_pos_x_old[playerID] = unit_x;
                p_pos_y_old[playerID] = unit_y;
                unit_is_moving = 1;
            }
            if (!unit_is_moving && unit.currentSpeed1 > 0) {
                unit.currentSpeed1 = 0; // Unit stuck because of flingy movement fix.
                unit.currentSpeed2 = 0;
            }
            if (unit_is_moving) {
                const x, y = GetChunkAtPos(unit_x, unit_y);
                if (p_chunk_x_old[playerID] != x || p_chunk_y_old[playerID] != y) {
                    p_chunk_x_old[playerID] = x;
                    p_chunk_y_old[playerID] = y;
                    JustEnteredChunk(x, y);
                }
                p_indoors[playerID] = IsPosIndoors(unit_x, unit_y);
            }
            UpdateBrightness(playerID);
            UpdateSightRange(playerID);

            // HEALTH
            if (IsAlive(playerID)) {

            }

            // ARMOR
            if (IsAlive(playerID)) {
                CenterLocHero(L_16x16, playerID);
                CenterLocHero(L_3X3, playerID);
                if (p_armor_max[playerID] > 0 && EnemiesAtLoc(L_16x16)) {
                    if (EnemiesAtLoc(L_3X3) && p_armor_recover[playerID] == 0) p_armor_recover[playerID] = 1;
                } else {
                    if (unit.shield < p_armor_max[playerID]) unit.shield += 10 * 256;
                }
                if (!EnemiesAtLoc(L_3X3) && p_armor_recover[playerID] > 0) {
                    p_armor_recover[playerID] = 0;
                    unit.shield = p_armor_max[playerID];
                    CreateImageSpriteAtLocation($P8, L_3X3, 377, 0);
                    PlayWAV("staredit/wav/dodge.ogg");
                }
                if (unit.shield > p_armor_max[playerID]) unit.shield = p_armor_max[playerID];
                if (unit.shield >= 256) p_armor_old[playerID] = unit.shield;
                if (unit.shield < 256 && p_armor_old[playerID] > 256) {
                    p_armor_old[playerID] = 0;
                    // armor broken
                    DisplayText("ARMOR BROKEN");
                    PlayWAV("staredit/wav/shields_broke.ogg");
                    setloc(L_MAIN, unit_x, unit_y);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 107, 16);
                }
            }

            // UNIT ATTACK
            if (IsAlive(playerID)) {
                if (unit.groundWeaponCooldown == 26) {
                    unit_just_attacked = 1;
                    unit.groundWeaponCooldown -= p_attackspeed[playerID];
                    const target = unit.orderTargetUnit;
                    const target_state = DamageUnit(target, p_damage[playerID], ACTIVE_UNITS_MAX + 1);
                    if (target_state == 0) {
                        RedeemUnitExp(playerID, target.unitType);
                    }
                }
            }

            // if (unit_just_attacked) {
            //     DisplayText("attacked.");
            //     queue_event_owner = playerID;
            //     queue_event_posx = unit_x;
            //     queue_event_posy = unit_y;
            //     queue_event_size = 128;
            //     queue_event_damage = 12;
            //     queue_event_maxtime = 1;
            //     CreateEvent();
            // }

            // EXP
            if (p_exp_current[playerID] >= p_exp_goal[playerID]) {
                LevelUp(playerID);
            }

            // TIME
            if (time_state_changed) {
                if (time_state == 0) {
                    DisplayText("DAY TIME!!!!!");
                    PlaySong(0);
                }
                else if (time_state == 1) {
                    DisplayText("NIGHT TIME!!!!!");
                    PlayWAV("staredit/wav/night_ambience.ogg");
                }
            }

            if (debug_enabled) {
                // if (test_delay == 0 && playerID == 0) {
                //     test_delay = 12;
                //     queue_pro_angle = SCDirectionToDeg(unit.currentDirection1);
                //     queue_pro_velocity = Random(10, 50);
                //     queue_pro_posx, queue_pro_posy = unit_x, unit_y;
                //     queue_pro_maxtime = 24;
                //     // queue_pro_angular_velocity = Random(-30, 30);
                //     queue_pro_effect0 = 443;
                //     queue_pro_effect0_start = 0;
                //     queue_pro_effect1 = 523;
                //     queue_pro_effect1_start = 24;
                //     queue_pro_effect2 = 427;
                //     queue_pro_effect2_start = queue_pro_maxtime;
                //     CreateProjectile();
                //     // for (var u = playerID * ACTIVE_UNITS_MAX; u < playerID + 1 * ACTIVE_UNITS_MAX; u++) {
                //     //     if (active_units[u] > 0) {
                //     //         const enemy_unit = CUnit(active_units[u]);
                //     //         // setloc(L_MAIN, enemy_unit_x, enemy_unit_y);
                //     //         // CreateUnitDeathAtLocation(U_KAKARU, playerID, L_MAIN);
                //     //         queue_pro_angle = Random(0, 359);
                //     //         queue_pro_velocity = Random(10, 50);
                //     //         queue_pro_posx, queue_pro_posy = enemy_unit_x, enemy_unit_y;
                //     //         queue_pro_maxtime = 24;
                //     //         // queue_pro_angular_velocity = Random(-30, 30);
                //     //         queue_pro_effect0 = 443;
                //     //         queue_pro_effect0_start = 0;
                //     //         queue_pro_effect1 = 523;
                //     //         queue_pro_effect1_start = 24;
                //     //         queue_pro_effect2 = 427;
                //     //         queue_pro_effect2_start = queue_pro_maxtime;
                //     //         CreateProjectile();
                //     //     }
                //     // }
                // }
                if (!IsAlive(playerID)) {
                    setloc(L_MAIN, p_homepos_x[playerID], p_homepos_y[playerID]);
                    SpawnHero(playerID, L_MAIN);
                    CenterView(L_MAIN);
                }
                debug_values[0] = unit.currentDirection1;
                debug_values[1] = SCDirectionToDeg(unit.currentDirection1);
                debug_values[2] = p_exp_goal[playerID];
                // if (order_input == ORDER_HOLD) {
                //     SetMaxHP(playerID, p_health_max[playerID] - 10);
                // } 
                // else if (order_input == ORDER_PATROL) {
                //     SetMaxHP(playerID, p_health_max[playerID] + 10);
                // }
                eprintf("{} | {} | {} | {} | {} | {} | {} | {}", debug_values[0], debug_values[1], debug_values[2], debug_values[3], debug_values[4], debug_values[5], debug_values[6], debug_values[7]);
            }
        }
    EUDEndPlayerLoop();
    if (active_units_update == 0) active_units_update = 24;
    active_units_update -= 1;
}